
// Precondition: fst >= fin
//
foldRangeDown = { forall t:Type,
              fst : Int32 =>
              fin : Int32 =>
              init : t =>
              iter : { Int32 => t => t } =>
  REC frd =  { n : Int32 => acc : t =>
                if n >=SInt32 fin then
                  frd (n -Int32 1) (iter n acc)
                else acc end
            };
  frd fst init
};

// Precondition: fst <= fin
//
foldRange = { forall t:Type,
              fst : Int32 =>
              fin : Int32 =>
              init : t =>
              iter : { Int32 => t => t } =>
  REC go = { n : Int32 => acc : t =>
      if n >=SInt32 fin then acc else
        go (n +Int32 1) (iter n acc)
      end
  };
  go fst init;
};

// Precondition: fst <= fin
//
foldRange64 = { forall t:Type,
                  fst : Int64 =>
                  fin : Int64 =>
                  init : t =>
                  iter : { Int64 => t => t } =>
  REC go = { n : Int64 => acc : t =>
      if n >=SInt64 fin then acc else
        go (n +Int64 1) (iter n acc)
      end
  };
  go fst init;
};

/////

arrayFoldl :: forall t:Type, a:Type, { Array t => { t => a => a } => a => a };
arrayFoldl = { arr => f => acc =>
  arrayFoldlFrom arr 0 f acc
};

arrayFoldlFrom :: forall t:Type, a:Type, { Array t => Int32 => { t => a => a } => a => a };
arrayFoldlFrom = { arr => offset => f => acc =>
  arrayFoldlFromTo arr offset (arrayLength32 arr) f acc
};

arrayFoldlFromTo :: forall t:Type, a:Type, { Array t => Int32 => Int32 => { t => a => a } => a => a };
arrayFoldlFromTo = { arr => offset => len => f => acc =>
  foldRange offset len acc { n : Int32 => acc => f arr[n] acc }
};

////

arrayLength :: forall x:Type, { % ra : Array x : True =>
                                % rv : Int64 : rv ==Int64 prim_arrayLength:[x] ra };
arrayLength = { a : Array x => prim_arrayLength a };

arrayLength32 :: forall x:Type, { % ra : Array x : True =>
                                  % rv : Int32 : rv ==Int32 trunc_i64_to_i32 (prim_arrayLength:[x] ra) };
arrayLength32 = { a : Array x => trunc_i64_to_i32 (prim_arrayLength a) };

arrayLengthWord :: forall x:Type, { % ra : Array x : True =>
                                    % rv : Word : rv ==Word trunc_i64_to_Word (prim_arrayLength:[x] ra) };
arrayLengthWord = { a : Array x => trunc_i64_to_Word (prim_arrayLength a) };


incr64 = { n : Int64 => n +Int64 1 };

arrayEnumFromTo = { forall t:Type,
                  a : Array t =>
                  k : Int64 =>
                  x : Int64 =>
                  f : { t => Int64 => () } =>
  if k <SInt64 x
    then f a[trunc_i64_to_i32 k] k;
         arrayEnumFromTo a (incr64 k) x f
    else ()
  end
};

arrayEnumFrom = { forall t:Type,
                  a : Array t =>
                  k : Int64 =>
                  f : { t => Int64 => () } =>
  arrayEnumFromTo a k (arrayLength a) f
};

arrayEnum = { forall t:Type,
              a : Array t =>
              f : { t => Int64 => () } =>
  arrayEnumFromTo a 0 (arrayLength a) f
};

/*
arrayEach = { forall t:Type,
              a : Array t =>
              f : { t => () } =>
  arrayEnum a { ign:Int64 => v:t => f v };
};
*/

arrayFoldFrom = { forall t:Type r:Type,
                  a : Array t =>
                  k : Int64 =>
                  f : { t => Int64 => r => r } =>
                  acc : r =>
  if k <SInt64 prim_arrayLength a
    then arrayFoldFrom a (incr64 k) f (f a[trunc_i64_to_i32 k] k acc)
    else acc
  end
};

arrayFold = { forall t:Type r:Type,
              a : Array t =>
              f : { t => Int64 => r => r } =>
              acc : r =>
  arrayFoldFrom a 0 f acc
};


