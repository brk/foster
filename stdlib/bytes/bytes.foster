snafuinclude PreludeFixnums "prelude-fixnums";
snafuinclude PreludeFolds   "prelude-folds";

// Immutable wrapper around Array Int8 with enhanced asymptotics
// for common operations like concatenation of bytes and taking slices/views
// of byte arrays.
// Standard sequence types like VList are currently limited to boxed types.
// TODO would a specialization of VList perform better?

type case Bytes
  of $BytesEmpty
  of $BytesFragment (Array Int8) Int64
  of $BytesConcat   Bytes Bytes  Int64
          // possible-but-not-yet-enforced invariant: sub-bytes not BytesEmpty.
  of $BytesOffset   Bytes Int64  Int64
          // invariant: remaining len > 0
          // invariant: sub-bytes not BytesOffset
;

rawBytesConcatByCopy = { a : Array Int8 => alen : Int32 =>
                         b : Array Int8 => blen : Int32 => len : Int32 =>
  if blen ==Int32 0 then a else
    // We do this somewhat-unsatisfactory dance of allocating a (mutable) array,
    // then filling its contents in via an exposed memcpy primitive.
    // It would be nicer to have (byte-)array concatenation be a primitive of the
    // runtime, but that would require the compiler to statically provide the
    // runtime with the typeinfo needed to call memalloc_array.
    //
    // It's also not great that using this in a loop gives O(n^2) asympotic
    // complexity rather than O(n), because we don't over-allocate our arrays.
    bytes = allocDArray len;

    // bytes[0..whatever]    = a[0..alen]
    memcpy_i8_to_at_from_len bytes 0    a alen;

    // bytes[alen..whatever] = b[0..blen]
    memcpy_i8_to_at_from_len bytes alen b blen;

    bytes
  end
};


bytesOfRawArray :: { Array Int8 => Bytes };
bytesOfRawArray = { a => BytesFragment a (prim_arrayLength a) };

bytesLength :: { Bytes => Int64 };
bytesLength = { ba =>
  case ba
    of $BytesEmpty          -> 0
    of $BytesFragment _ len -> len
    of $BytesConcat _ _ len -> len
    of $BytesOffset _ _ len -> len
  end
};

bytesLength32 :: { Bytes => Int32 };
bytesLength32 =  { bytes => bytesLength bytes |> lossless_trunc_i64_to_i32  };

bytesConcat :: { Bytes => Bytes => Bytes };
bytesConcat = { ba => bb =>
  lena = bytesLength ba;
  if lena ==Int64 0 then bb else
    lenb = bytesLength bb;
    if lenb ==Int64 0 then ba else
      len = lena +Int64 lenb;
      BytesConcat ba bb len
    end
  end
};

bytesConcatAlt :: { Bytes => Bytes => Bytes };
bytesConcatAlt = { ba => bb =>
  case (bytesLength ba, bytesLength bb)
    of (0, _) -> bb
    of (_, 0) -> ba
    of (lena, lenb) -> BytesConcat ba bb (lena +Int64 lenb)
  end
};

bytesDrop :: { Bytes => Int64 => Bytes };
bytesDrop = { ba => n =>
  if n ==Int64 0 then ba else
    len = bytesLength ba -Int64 n;
    if len <=SInt64 0
      then BytesEmpty
      else case ba
            // TODO could drop half a concat if n is big enough.
            of $BytesConcat bb bc _ ->
              if bytesLength bb <=SInt64 n
                then bytesDrop bc (n -Int64 bytesLength bb)
                else // rather than re-concat a projection of the drop,
                     // and potentially do multiple allocations,
                     // we'll just wrap the concat in an offset...
                                      BytesOffset ba n            len
              end
            of $BytesOffset bb m _ -> BytesOffset bb (n +Int64 m) len
            of _                   -> BytesOffset ba n            len
          end
    end
  end
};

bytesDrop32 :: { Bytes => Int32 => Bytes };
bytesDrop32 = { ba => n => bytesDrop ba (zext_i32_to_i64 n) };

// Precondition: len >= 0
// Postcondition: bytesLength (bytesTake b n) == min n (bytesLength b)
bytesTake :: { Bytes => Int64 => Bytes };
bytesTake = { ba => len =>
  // [aaaaaaaaaaaaaaaa]
  //          len
  if len ==Int64 0 then BytesEmpty else
  if len >=SInt64 bytesLength ba
    then ba
    else case ba
           of $BytesFragment arr _ -> BytesFragment arr len
           of $BytesOffset bb  m _ -> BytesOffset  bb m len
           of $BytesConcat bb bc _ ->
             lenFromC = len -Int64 bytesLength bb;
             if lenFromC <=SInt64 0
               then bytesTake bb len
               else bytesConcat bb (bytesTake bc lenFromC)
             end
           of _ -> prim kill-entire-process "bytesTake invariant violated";
         end
  end
  end
};

// Precondition: o is a valid index for b.
bytesFoldlBytes :: forall a:Type, { Bytes => { Int8 => a => a } => a => a };
bytesFoldlBytes = { ba => f => acc =>
  // TODO(opt) this helper can't be contified (due to multiple continuations),
  // so it will result in dynamic allocation,
  // but its closure will be empty, meaning it could have been split out into
  // a top-level function, thus avoiding dynamic allocation of an empty closure.
  // That capability should be added to the contification pass,
  // or the closure-conversion pass, or something...
  REC go = { bytes => f => offset : Int64 => len : Int64 => acc =>
      case bytes
        of $BytesFragment arr _ ->
            arrayFoldlFromTo arr (lossless_trunc_i64_to_i32 offset)
                                 (lossless_trunc_i64_to_i32 (len +Int64 offset)) f acc
        of $BytesOffset bb m len -> go bb f (offset +Int64 m) len acc
        of $BytesConcat bb bc _ ->
          bblen = bytesLength bb;
          afterdrop = offset -Int64 bblen;
          if afterdrop <SInt64 0
             // offset - bblen < 0 ==> bblen > offset ==>  bblen - offset > 0
            then go bb f offset bblen acc |>
                 go bc f 0 (len -Int64 bytesLength bb)
            else go bc f afterdrop (len -Int64 bytesLength bb) acc
          end
        of $BytesEmpty -> acc
      end
  };
  go ba f 0 (bytesLength ba) acc
};

// Precondition: o is a valid index for b.
bytesGet!    :: { Int64 => Bytes => Int8 };
bytesGet! = { o => ba =>
  case ba
    of $BytesFragment arr _ -> arr[trunc_i64_to_i32 o];
    of $BytesOffset bb m  _ -> bytesGet! (o +Int64 m) bb;
    of $BytesConcat bb bc _ ->
      afterdrop = o -Int64 bytesLength bb;
      if afterdrop <SInt64 0
        then bytesGet! o bb
        else bytesGet! afterdrop bc
      end
    of $BytesEmpty          -> prim kill-entire-process "bytesGet! of BytesEmpty";
  end
};

// Precondition: 0 is a valid index for b.
bytesGet0! :: { Bytes => Int8 };
bytesGet0! = { ba =>
  case ba
    of $BytesFragment arr _ -> arr[0];
    of $BytesOffset bb m  _ -> bytesGet! m bb;
    of $BytesConcat bb bc _ -> bytesGet0! bb;
    of $BytesEmpty          -> prim kill-entire-process "bytesGet0! of BytesEmpty";
  end
};

// Precondition: n is a valid index for b.
// TODO would bytesGet o b = bytesGet0 (bytesDrop b o) be efficiently compiled?
bytesGetAlt1! :: { Bytes => Int64 => Int8 };
bytesGetAlt1! = { b => n =>
  bytesGet0! (bytesDrop b n)
};

bytesGetAlt2! :: { Bytes => Int64 => Int8 };
bytesGetAlt2! = { b => n =>
  bytesGet! 0 (bytesDrop b n)
};

// bytesPackList  :: { List Int8 => Bytes };
// bytesToUTF8 :: { Bytes => Text };
// bytesOfUTF8 :: { Text => Bytes };

// Precondition: i..i+7 are valid indices for bytes.
bytesGet8LE! :: { Bytes => Int64 => Int64 };
bytesGet8LE! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  c = bytesGet! (i +Int64 2) bytes;
  d = bytesGet! (i +Int64 3) bytes;
  e = bytesGet! (i +Int64 4) bytes;
  f = bytesGet! (i +Int64 5) bytes;
  g = bytesGet! (i +Int64 6) bytes;
  h = bytesGet! (i +Int64 7) bytes;
  mergeInt32 (octet4ToInt32 h g f e)
             (octet4ToInt32 d c b a)
};

bytesGet8LE!Alt = { bytes => i =>
  mergeInt32 (bytesGet4LE! bytes (i +Int64 4))
             (bytesGet4LE! bytes  i          )
};

// Precondition: i..i+3 are valid indices for bytes.
bytesGet4LE! :: { Bytes => Int64 => Int32 };
bytesGet4LE! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  c = bytesGet! (i +Int64 2) bytes;
  d = bytesGet! (i +Int64 3) bytes;
  octet4ToInt32 d c b a
};

// Precondition: i..i+2 are valid indices for bytes.
bytesGet3LE! :: { Bytes => Int64 => Int32 };
bytesGet3LE! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  c = bytesGet! (i +Int64 2) bytes;
  octet4ToInt32 0 c b a
};

// Precondition: i..i+1 are valid indices for bytes.
bytesGet2LE! :: { Bytes => Int64 => Int32 };
bytesGet2LE! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  octet4ToInt32 0 0 b a
};

// Precondition: i is a valid index for bytes.
bytesGet1LE! :: { Bytes => Int64 => Int32 };
bytesGet1LE! = { bytes => i =>
  a = bytesGet! i bytes;
  octet4ToInt32 0 0 0 a
};

// Precondition: i..i+3 are valid indices for bytes.
bytesGet4BE! :: { Bytes => Int64 => Int32 };
bytesGet4BE! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  c = bytesGet! (i +Int64 2) bytes;
  d = bytesGet! (i +Int64 3) bytes;
  octet4ToInt32 a b c d
};

// Precondition: i..i+2 are valid indices for bytes.
bytesGet3BE! :: { Bytes => Int64 => Int32 };
bytesGet3BE! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  c = bytesGet! (i +Int64 2) bytes;
  octet4ToInt32 0 a b c
};

// Precondition: i..i+1 are valid indices for bytes.
bytesGet2BE! :: { Bytes => Int64 => Int32 };
bytesGet2BE! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  octet4ToInt32 0 0 a b
};

// Precondition: i is a valid index for bytes.
bytesGet1BE! :: { Bytes => Int64 => Int32 };
bytesGet1BE! = { bytes => i =>
  a = bytesGet! i bytes;
  octet4ToInt32 0 0 0 a
};

// Precondition: i..i+3 are valid indices for bytes.
bytesGet4HI! :: { Bytes => Int64 => Int32 };
bytesGet4HI! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  c = bytesGet! (i +Int64 2) bytes;
  d = bytesGet! (i +Int64 3) bytes;
  octet4ToInt32 a b c d
};

// Precondition: i..i+2 are valid indices for bytes.
bytesGet3HI! :: { Bytes => Int64 => Int32 };
bytesGet3HI! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  c = bytesGet! (i +Int64 2) bytes;
  octet4ToInt32 a b c 0
};

// Precondition: i..i+1 are valid indices for bytes.
bytesGet2HI! :: { Bytes => Int64 => Int32 };
bytesGet2HI! = { bytes => i =>
  a = bytesGet! (i +Int64 0) bytes;
  b = bytesGet! (i +Int64 1) bytes;
  octet4ToInt32 a b 0 0
};

// Precondition: i is a valid index for bytes.
bytesGet1HI! :: { Bytes => Int64 => Int32 };
bytesGet1HI! = { bytes => i =>
  a = bytesGet! i bytes;
  octet4ToInt32 a 0 0 0
};

