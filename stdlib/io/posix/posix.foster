snafuinclude Bytes "bytes";

// Note: these function names are treated specially in fosterlower.cpp
// to resolve the LLVM type-level mismatch between Array Int8,
// which has type { i64, [0 x i8] }*,
// and the closest we can get from C-land, which is %struct.foster_bytes*.

foster_stdin_read_bytes :: { Array Int8 => Ref Int32 => Int64 } @ { proc = true };

//                             (fd)      (bytes)     (offset)  (len)    (status)    (#rd/wr)
foster_posix_read_bytes  :: { Int64 => Array Int8 => Int64 =>          Ref Int32 => Int64 } @ { proc = true };
foster_posix_write_bytes :: { Int64 => Array Int8 => Int64 => Int64 => Ref Int32 => Int64 } @ { proc = true };

foster_posix_get_tuntap_fd :: { Int64 } @ { proc = true };

type case IORead
      of $IOReadDone  Bytes
      of $IOReadMore  Bytes
      of $IOReadLater Bytes
      of $IOReadError Bytes
;


read_stdin_bytes_list :: { Bytes };
read_stdin_bytes_list = {
  // Note: this implementation produces a linear chain of exponentially-growing
  // fragments, such that access to the first byte from stdin requires
  // traversing the whole "list" of chunks. For now, we don't call bytesFlatten
  // ourselves, but callers may wish to do so...
  REC go = { prefix => size =>
    case read_stdin_bytes_chunk size // roughly sqrt 2^30...
      of $IOReadDone  bytes -> bytesConcat prefix bytes
      of $IOReadMore  bytes -> go (bytesConcat prefix bytes) (size *Int32 2)
      of $IOReadLater bytes -> go (bytesConcat prefix bytes) (size *Int32 2)
      of $IOReadError _ -> prim kill-entire-process "read_stdin_bytes_list failed";
    end
  };
  go BytesEmpty 1024
};

read_stdin_bytes_chunk :: { Int32 => IORead };
read_stdin_bytes_chunk = { size =>
  arr   = allocDArray:[Int8] size;
  rstatus = (prim ref 0);
  nread = foster_stdin_read_bytes arr rstatus;
  bytes = bytesTake (bytesOfRawArray arr) nread;
  case rstatus^
    of 0 -> IOReadDone bytes
    of 1 -> IOReadMore bytes
    of 2 -> IOReadLater bytes
    of _ -> IOReadError bytes
  end
};
