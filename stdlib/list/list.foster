snafuinclude Maybe "maybe";

type case List (a:Boxed)
  of $Nil
  of $Cons a (List a)
;

// Precondition: List is not empty.
listHead! :: forall t:Boxed, { List t => t };
listHead! = { forall t:Boxed, xs : List t =>
  case xs
    of $Nil -> prim kill-entire-process "listHead! passed an empty list"
    of $Cons x _ -> x
  end
};

// Precondition: List is not empty.
listTail! :: forall t:Boxed, { List t => List t };
listTail! = { forall t:Boxed, xs : List t =>
  case xs
    of $Nil -> prim kill-entire-process "listTail! passed an empty list"
    of $Cons _ ys -> ys
  end
};

// Precondition: i >= 0, listLength xs > i
listGet! = { forall t:Boxed, xs : List t => i : Int32 =>
  unMaybe (listGet xs i)
};

listGet = { forall t:Boxed, xs : List t => i : Int32 =>
  if i <SInt32 0 then None ! else
    // invariant: i >= 0.
    REC go = { xs => i =>
      case xs
        of $Nil -> None !
        of $Cons y ys ->
          if i ==Int32 0 then Some y else
            go ys (i -Int32 1)
          end
      end
    };
    go xs i;
  end
};

// Uses O(1) stack, and heap proportional to whatever f allocates.
listFoldl :: forall a:Boxed, e:Boxed, { List e => { e => a => a } => a => a };
listFoldl = { forall a:Boxed e:Boxed, v => f => acc : a =>
  case v
    of $Nil            -> acc
    of $Cons head tail -> listFoldl tail f (f head acc)
  end
};

listMap :: forall a:Boxed, e:Boxed, { List e => { e => a } => List a };
listMap = { forall a:Boxed e:Boxed, v => f =>
  listFoldl v { e => tail => Cons (f e) tail } (Nil !);
};

listLength = { forall t:Boxed, xs : List t =>
  REC go = { xs => acc =>
    case xs
      of $Nil -> acc
      of $Cons x ys -> go ys (acc +Int32 1)
    end
  };
  go xs 0
};

/* Can't yet do this because of Boxed/Type kind mismatch
listLengthAlt = { forall t:Boxed, xs : List t =>
  listFoldl xs { e => len => 1 +Int32 len } 0
};
*/

listReverse = { forall t:Boxed, xs : List t =>
  REC go = { xs : List t => acc : List t =>
    case xs
      of $Nil -> acc
      of $Cons x ys -> go ys (Cons x acc)
    end
  };
  go xs (Nil !)
};

listReverseAlt = { forall t:Boxed, xs : List t =>
  listFoldl xs Cons (Nil !)
};

listAppend :: forall t:Boxed, { List t => List t => List t };
listAppend = { forall t:Boxed, xs => ys =>
  REC go = { rev => acc =>
    case rev
      of $Nil -> acc
      of $Cons z zs -> go zs (Cons z acc)
    end
  };
  go (listReverse xs) ys
};

listAppendAlt :: forall t:Boxed, { List t => List t => List t };
listAppendAlt = { forall t:Boxed, xs => ys =>
  listFoldl (listReverse xs) Cons ys
};

listIter :: forall a:Boxed, { List a => { a => () } => () };
listIter = { forall a:Boxed, v => f =>
  case v
    of $Nil            -> ()
    of $Cons head tail -> f head; listIter tail f;
  end
};
