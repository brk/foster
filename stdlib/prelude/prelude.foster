snafuinclude List "list";
snafuinclude Ord  "ord";
snafuinclude Text "text";
snafuinclude Primitives "primitives";

// TODO test codegen of not_ vs primitive not
not_   = { a : Bool => if a then False else True end };

either = { a : Bool => b : Bool => if a then True else b     end };
both   = { a : Bool => b : Bool => if a then b    else False end };

oror   = { a : { Bool } => b : { Bool } => if a ! then True else b !   end };
andand = { a : { Bool } => b : { Bool } => if a ! then b !  else False end };

when   = { a : Bool => f : { () } => if a then f ! else () end };

while = { cond : { Bool } => body : { () } =>
  if cond ! then body ! ; while cond body else () end
};

until = { cond : { Bool } => body : { () } =>
  if cond ! then () else body ! ; until cond body end
};

/////

cmpSInt32 = { a : Int32 => b : Int32 =>
  if a ==Int32 b
  then EQ
  else if a <SInt32 b then LT else GT end
  end
};

cmpSInt64 = { a : Int64 => b : Int64 =>
  if a ==Int64 b
  then EQ
  else if a <SInt64 b then LT else GT end
  end
};

cmpUInt32 = { a : Int32 => b : Int32 =>
  if a ==Int32 b
  then EQ
  else if a <UInt32 b then LT else GT end
  end
};

cmpUInt64 = { a : Int64 => b : Int64 =>
  if a ==Int64 b
  then EQ
  else if a <UInt64 b then LT else GT end
  end
};

cmpUWord = { a : Word => b : Word =>
  if a ==Word b
  then EQ
  else if a <UWord b then LT else GT end
  end
};

cmpSWord = { a : Word => b : Word =>
  if a ==Word b
  then EQ
  else if a <SWord b then LT else GT end
  end
};

/////

// Precondition: fst >= fin
//
foldRangeDown = { forall t:Type,
              fst : Int32 =>
              fin : Int32 =>
              init : t =>
              iter : { Int32 => t => t } =>
  REC frd =  { n : Int32 => acc : t =>
                if n >=SInt32 fin then
                  frd (n -Int32 1) (iter n acc)
                else acc end
            };
  frd fst init
};

// Precondition: fst <= fin
//
foldRange = { forall t:Type,
              fst : Int32 =>
              fin : Int32 =>
              init : t =>
              iter : { Int32 => t => t } =>
  REC go = { n : Int32 => acc : t =>
      if n >=SInt32 fin then acc else
        go (n +Int32 1) (iter n acc)
      end
  };
  go fst init;
};

/////

arrayFoldl :: forall t:Type, a:Type, { Array t => { t => a => a } => a => a };
arrayFoldl = { arr => f => acc =>
  foldRange 0 (arrayLength32 arr) acc { n : Int32 => acc => f arr[n] acc }
};

/////

bitlength-Int64 :: { Int64 => Int32 };
bitlength-Int64 = { k =>
  rec go = { x => acc =>
                 if x ==Int64 0
                   then acc
                   else go (bitlshr-Int64 x 1) (acc +Int32 1)
                 end
           };
  in
    go k 0
  end
};

// TODO should this be called wordCountBits instead?
// Note: this function implements the function called _BitScanReverse,
//       which is equal to llvm.ctlz(0, 0) - llvm.ctlz(k, 0).
bitlength-Word :: { Word => Int32 };
bitlength-Word = { k =>
  rec go = { x => acc =>
                 if x ==Word 0
                   then acc
                   else go (bitlshr-Word x 1) (acc +Int32 1)
                 end
           };
  in
    go k 0
  end
};

/////

// Specialization of popcount(-1 :: Word).
// Assumption: Word is either 32 or 64 bits.
wordNumBits32 :: { Int32 };
wordNumBits32 = {

    if 0 ==Word bitxor-Word (-1) 0FFFF`FFFF_16
      then 32
      else 64
    end

};

wordNumBits :: { Word };
wordNumBits = {
  sext_i32_to_Word (wordNumBits32 !)
};

/////

// Computes the following function::
//     x: f(x)
//     0: 0
//     1: 1
//     2: 2
//     3: 2
//     4: 4
//     ...
//     7: 4
//     8: 8
//     9: 8
//     ...
//     127: 64
//     128: 128
//     129: 128
highestBitMask-Word :: { Word => Word };
highestBitMask-Word = { x0 =>
  x1 = x0 `bitor-Word` (x0 `bitlshr-Word` 1);
  x2 = x1 `bitor-Word` (x1 `bitlshr-Word` 2);
  x3 = x2 `bitor-Word` (x2 `bitlshr-Word` 4);
  x4 = x3 `bitor-Word` (x3 `bitlshr-Word` 8);
  x5 = x4 `bitor-Word` (x4 `bitlshr-Word` 16);
  // In LLVM, shifting a 32-bit value 32 bits
  // produces undefined, not zero.
  x6 = if 0 ==Word bitxor-Word (-1) 0FFFF`FFFF_16
          then x5 // 32 bits in a word
          else    // 64 bits in a word
               x5 `bitor-Word` (x5 `bitlshr-Word` 32);
       end;
  x6 `bitxor-Word` (x6 `bitlshr-Word` 1);
};

/////

// Precondition: m >= n
copyOfArrayTo :: forall t:Type,
                 { Array t => // of length m
                   /*n:*/Int32 =>
                   Array t    // of length n
                 };
copyOfArrayTo = { forall t:Type,
                   a => n =>
  assert (arrayLength a >=UInt64 (zext_i32_to_i64 n)) "copyOfArrayTo";
  newDArray0:[t] n { i : Int32 => a[i] };
};

/////

max-Int32 = { n : Int32 => m : Int32 => if n <SInt32 m then m else n end };
max-SInt32 = { n : Int32 => m : Int32 => if n <SInt32 m then m else n end };
max-SInt64 = { n : Int64 => m : Int64 => if n <SInt64 m then m else n end };
max-SWord  = { n : Word  => m : Word  => if n <SWord  m then m else n end };

text_maxdepth = { s : Text =>
  case s
    of $TextFragment a n     -> 0
    of $TextConcat   s1 s2 n -> 1 +Int32
                               (max-Int32 (text_maxdepth s1) (text_maxdepth s2))
   end;
};

textOfBool = { b : Bool =>
  if b then "True" else "False" end
};

// Precondition: n in range 0..128.
textOfASCII = { n : Int32 => textOfASCII8 (trunc_i32_to_i8 n) };

// Precondition: n in range 0..128.
textOfASCII8 = { n : Int8 =>
  a = newDArray:[Int8] 1 { i => n };
  TextFragment a 1
};

////

arrayLength :: forall x:Type, { Array x => Int64 };
arrayLength = { forall t:Type, a : Array t =>
  prim_arrayLength a
};

arrayLength32 :: forall x:Type, { Array x => Int32 };
arrayLength32 = { forall t:Type, a : Array t =>
  trunc_i64_to_i32 (prim_arrayLength a)
};

arrayLengthWord :: forall x:Type, { Array x => Word };
arrayLengthWord = { forall t:Type, a : Array t =>
  trunc_i64_to_Word (prim_arrayLength a)
};

arrayEnumFromTo = { forall t:Type,
                  a : Array t =>
                  k : Int64 =>
                  x : Int64 =>
                  f : { t => Int64 => () } =>
  if k <SInt64 x
    then f a[trunc_i64_to_i32 k] k;
         arrayEnumFromTo a (incr64 k) x f
    else ()
  end
};

arrayEnumFrom = { forall t:Type,
                  a : Array t =>
                  k : Int64 =>
                  f : { t => Int64 => () } =>
  arrayEnumFromTo a k (arrayLength a) f
};

arrayEnum = { forall t:Type,
              a : Array t =>
              f : { t => Int64 => () } =>
  arrayEnumFromTo a 0 (arrayLength a) f
};

/*
arrayEach = { forall t:Type,
              a : Array t =>
              f : { t => () } =>
  arrayEnum a { ign:Int64 => v:t => f v };
};
*/

// Initializes slot a[k] with f (k + 1)
newDArray = { forall v:Type,
                n : Int32 =>
                f : { Int32 => v } =>
  a = allocDArray:[v] n;
  x = (ref n);

  until { x^ ==Int32 0 } {
      f x^      >^ a[x^ -Int32  1];
       (x^ -Int32 1) >^ x
  };
  a
};

// Initializes slot a[k] with (f k)
newDArray0 = { forall v:Type,
                n : Int32 =>
                f : { Int32 => v } =>
  a = allocDArray:[v] n;
  x = (ref n);

  until { x^ ==Int32 0 } {
      y = x^ -Int32 1;
      (f y) >^ a[y];
         y  >^ x
  };
  a
};

// Returns True on success, otherwise False.
arrayIterReverse = { forall t:Type,
                           a : Array t =>
                           n : Int32 => // invariant: n < len a
                           f : { t => Bool } =>
  if n >=SInt32 0 // TODO change this to avoid needing wraparound here.
  then if f a[n] then arrayIterReverse a (n -Int32 1) f
                 else False end
  else True end
};

////

min-Int32 = { a : Int32 => b : Int32 =>
  if a <SInt32 b then a else b end
};

// TODO improve error messages with
//      min-SInt64 = { a : Int32 => b : Int32 =>
min-SInt64 = { a : Int64 => b : Int64 =>
  if a <SInt64 b then a else b end
};

min-UInt64 = { a : Int64 => b : Int64 =>
  if a <UInt64 b then a else b end
};

minReprInt32 :: { Int32 };
minReprInt32 = { -2`147`483`648 };

maxReprInt32 :: { Int32 };
maxReprInt32 = {  2`147`483`647 };

minReprInt64 :: { Int64 };
minReprInt64 = { -9`223`372`036`854`775`808 };

maxReprInt64 :: { Int64 };
maxReprInt64 = {  9`223`372`036`854`775`807 };

octet4ToInt32 = { hi : Int8 => m1 : Int8 => m2 : Int8 => lo : Int8 =>
  (((zext_i8_to_i32 hi) `bitshl-Int32` 24)  `bitor-Int32`
   ((zext_i8_to_i32 m1) `bitshl-Int32` 16)) `bitor-Int32`
  (((zext_i8_to_i32 m2) `bitshl-Int32` 8)   `bitor-Int32`
    (zext_i8_to_i32 lo))
};

mergeInt32 = { hi : Int32 => lo : Int32 =>
  ((zext_i32_to_i64 hi) `bitshl-Int64` 32)  `bitor-Int64`
   (zext_i32_to_i64 lo)
};

////

// Returns True on success, otherwise False.
tmp_Text_bytes_iter_reverse = { t:Text =>
                                f: { Int8 => Bool } =>
  case t
    of $TextFragment a n     -> arrayIterReverse a (n -Int32 1) f;
    of $TextConcat   s1 s2 n ->
        if    tmp_Text_bytes_iter_reverse s2 f
         then tmp_Text_bytes_iter_reverse s1 f
         else False
        end
   end;
};

is_ascii_digit = { c : Int8 =>
  if   c <=SInt8 (trunc_i32_to_i8 57)
  then c >=SInt8 (trunc_i32_to_i8 48)
  else False
  end
};

tmp_Int32_of_base_10_Text = { t:Text =>
  acc = (ref 0);
  pow = (ref 1);
  base = 10;
  ok = tmp_Text_bytes_iter_reverse t { c : Int8 =>
   //print_text "is_ascii_digit c:"; // hmm, causes crash...
   if is_ascii_digit c
     then
       s = (sext_i8_to_i32 c) -Int32 48;
       (acc^ +Int32 (s *Int32 pow^)) >^ acc;
       (pow^           *Int32 base ) >^ pow;
       True
     else False
   end;
  };
  if ok then acc^ else 0 end
};

tmp_Text_of_Int32_digit = { n:Int32 =>
  case n
    of 0 -> "0"
    of 1 -> "1"
    of 2 -> "2"
    of 3 -> "3"
    of 4 -> "4"
    of 5 -> "5"
    of 6 -> "6"
    of 7 -> "7"
    of 8 -> "8"
    of 9 -> "9"
    of _ -> "<error:value passed to tmp_Text_of_Int32_digit was too large>"
  end
};

tmp_Text_16_of_Int32_digit = { n:Int32 =>
  case n
    of 0 -> "0"
    of 1 -> "1"
    of 2 -> "2"
    of 3 -> "3"
    of 4 -> "4"
    of 5 -> "5"
    of 6 -> "6"
    of 7 -> "7"
    of 8 -> "8"
    of 9 -> "9"
    of 10 -> "A"
    of 11 -> "B"
    of 12 -> "C"
    of 13 -> "D"
    of 14 -> "E"
    of 15 -> "F"
    of _ -> "<error:value passed to tmp_Text_16_of_Int32_digit was too large>"
  end
};

tmp_Text_of_Int32 = { n:Int32 => tmp_Text_of_Int64 (sext_i32_to_i64 n) };

tmp_Text_of_Int8  = { n:Int8  => tmp_Text_of_Int64 (sext_i8_to_i64 n) };

tmp_Text_2_of_Int8_nibble = { n : Int8 =>
  case n
    of 0  -> "0000"
    of 1  -> "0001"
    of 2  -> "0010"
    of 3  -> "0011"
    of 4  -> "0100"
    of 5  -> "0101"
    of 6  -> "0110"
    of 7  -> "0111"
    of 8  -> "1000"
    of 9  -> "1001"
    of 10 -> "1010"
    of 11 -> "1011"
    of 12 -> "1100"
    of 13 -> "1101"
    of 14 -> "1110"
    of 15 -> "1111"
    of _ -> "<error:value passed to tmp_Text_2_of_Int8_nibble was too large>"
  end
};

tmp_Text_2_of_UInt8 = { n:Int8 =>
  mkTextConcat (tmp_Text_2_of_Int8_nibble (bitand-Int8 15 (bitlshr-Int8 n 4)))
 (mkTextConcat (tmp_Text_2_of_Int8_nibble (bitand-Int8 15 n))
  "");
};

tmp_Text_2_of_UInt32 = { n:Int32 =>
  ttgo = { n:Int32 =>
    n0 = trunc_i32_to_i8 n;
    n1 = trunc_i32_to_i8 (bitlshr-Int32 n 8 );
    n2 = trunc_i32_to_i8 (bitlshr-Int32 n 16);
    n3 = trunc_i32_to_i8 (bitlshr-Int32 n 24);

     mkTextConcat (tmp_Text_2_of_UInt8 n3)
    (mkTextConcat (tmp_Text_2_of_UInt8 n2)
    (mkTextConcat (tmp_Text_2_of_UInt8 n1)
    (mkTextConcat (tmp_Text_2_of_UInt8 n0) "")))
  };
  ttgo n;
};

tmp_Text_2_of_SInt32 = { n:Int32 =>
  if n <SInt32 0
    then mkTextConcat "-" (tmp_Text_2_of_UInt32 (0 -Int32 n))
    else                   tmp_Text_2_of_UInt32 n
  end
};

textDrop = { d : Int32 => s : Text =>
  assert (textLength s >=SInt32 d) "textDrop";

  if d ==Int32 0 then s else
    case s
      // TODO resolve confusion between bytes/codepoints/glyphs.
      of $TextFragment a n     -> TextFragment (dropRawBytes a d) (n -Int32 d)
      of $TextConcat   s1 s2 n ->
        if textLength s1 <=SInt32 d
          then             textDrop (d -Int32 textLength s1) s2
          else TextConcat (textDrop  d s1)                   s2 (n -Int32 d)
        end
     end
  end
};

dropRawBytes = { a : Array Int8 => d : Int32 =>
  alen = arrayLength32 a -Int32 d;
  bytes = allocDArray alen;

  // bytes[0..alen]    = a[d..alen+d]
  memcpy_i8_to_from_at_len bytes a d    alen;
  bytes

/*
  alen = arrayLength32 a -Int32 d;
  newDArray0 alen { i => a[d +Int32 i] };
  */
};

high32BitsOf64 = { n : Int64 =>
  trunc_i64_to_i32 (bitlshr-Int64 n 32)
};

splitInt64 :: { Int64 => (Int32, Int32) };
splitInt64 = { n =>
  highbits = high32BitsOf64 n;
  lowbits  = high32BitsOf64 (bitshl-Int64 n 32);
  (highbits, lowbits)
};

tmp_Text_2_of_Word = { n:Word =>
  if wordNumBits32 ! ==Int32 32
     then tmp_Text_2_of_UInt32 (trunc_Word_to_i32 n);
     else tmp_Text_2_of_UInt64 (zext_Word_to_i64 n);
  end
};

tmp_Text_2_of_UInt64 = { n:Int64 =>
  case splitInt64 n of
    (na, nb) ->
      mkTextConcat (tmp_Text_2_of_UInt32 na) (tmp_Text_2_of_UInt32 nb)
  end
};

tmp_Text_of_Int64 = { n:Int64 =>
  if n <SInt64 0
    then mkTextConcat "-" (tmp_Text_of_UInt64 (negate-Int64 n))
    else                   tmp_Text_of_UInt64               n
  end
};

tmp_Text_of_UInt64 = { n:Int64 =>
  REC go = { n:Int64 => t:Text =>
    if n <SInt64 10
      then mkTextConcat (tmp_Text_of_Int32_digit (trunc_i64_to_i32 n)) t
      else r = trunc_i64_to_i32 (srem-Int64 n 10);
           q =                          sdiv-Int64 n 10 ;
           go q (mkTextConcat (tmp_Text_of_Int32_digit r) t);
    end
  };
  go n ""
};

tmp_Text_of_SWord = { n:Word =>
  if n <SWord 0
    then mkTextConcat "-" (tmp_Text_of_UWord (negate-Word n))
    else                   tmp_Text_of_UWord              n
  end
};

tmp_Text_of_UWord = { n:Word =>
  tmp_Text_of_UInt64 (zext_Word_to_i64 n)
};

////

f64-to-u32? = { a : Float64 =>
  if a <f64 2147483647.5
    then Some (f64-to-u32! a)
    else None
  end
};

f64-to-s32? = { a : Float64 =>
  if both (a <f64 1073741820.5) (a >f64 -1073741820.5)
    then Some (f64-to-s32! a)
    else None
  end
};

// Precondition: a < 2147483640.5
f64-to-u32! = { a : Float64 => prim f64-to-u32-unsafe a };

// Precondition: a < 1073741820.5 && a > -1073741820.5
f64-to-s32! = { a : Float64 => prim f64-to-s32-unsafe a };

////

// Precondition: b != 0
udiv!-Int32    = { a : Int32    => b : Int32    => prim udiv-unsafe-Int32 a b }; // :: Int32

// Precondition: b != 0
udiv!-Int64    = { a : Int64    => b : Int64    => prim udiv-unsafe-Int64 a b }; // :: Int64

// Precondition: b != 0
udiv!-Int8     = { a : Int8     => b : Int8     => prim udiv-unsafe-Int8 a b }; // :: Int8

// Precondition: b != 0
udiv!-Word     = { a : Word     => b : Word     => prim udiv-unsafe-Word a b }; // :: Word

// Precondition: b != 0
udiv!-WordX2   = { a : WordX2   => b : WordX2   => prim udiv-unsafe-WordX2 a b }; // :: WordX2

// Precondition: b != 0
urem!-Int32    = { a : Int32    => b : Int32    => prim urem-unsafe-Int32 a b }; // :: Int32

// Precondition: b != 0
urem!-Int64    = { a : Int64    => b : Int64    => prim urem-unsafe-Int64 a b }; // :: Int64

// Precondition: b != 0
urem!-Int8     = { a : Int8     => b : Int8     => prim urem-unsafe-Int8 a b }; // :: Int8

// Precondition: b != 0
urem!-Word     = { a : Word     => b : Word     => prim urem-unsafe-Word a b }; // :: Word

// Precondition: b != 0
urem!-WordX2   = { a : WordX2   => b : WordX2   => prim urem-unsafe-WordX2 a b }; // :: WordX2

///

// Precondition: b != 0
sdiv!-Int32    = { a : Int32    => b : Int32    => prim udiv-unsafe-Int32 a b }; // :: Int32

// Precondition: b != 0
sdiv!-Int64    = { a : Int64    => b : Int64    => prim udiv-unsafe-Int64 a b }; // :: Int64

// Precondition: b != 0
sdiv!-Int8     = { a : Int8     => b : Int8     => prim udiv-unsafe-Int8 a b }; // :: Int8

// Precondition: b != 0
sdiv!-Word     = { a : Word     => b : Word     => prim udiv-unsafe-Word a b }; // :: Word

// Precondition: b != 0
sdiv!-WordX2   = { a : WordX2   => b : WordX2   => prim udiv-unsafe-WordX2 a b }; // :: WordX2

// Precondition: b != 0
srem!-Int32    = { a : Int32    => b : Int32    => prim urem-unsafe-Int32 a b }; // :: Int32

// Precondition: b != 0
srem!-Int64    = { a : Int64    => b : Int64    => prim urem-unsafe-Int64 a b }; // :: Int64

// Precondition: b != 0
srem!-Int8     = { a : Int8     => b : Int8     => prim urem-unsafe-Int8 a b }; // :: Int8

// Precondition: b != 0
srem!-Word     = { a : Word     => b : Word     => prim urem-unsafe-Word a b }; // :: Word

// Precondition: b != 0
srem!-WordX2   = { a : WordX2   => b : WordX2   => prim urem-unsafe-WordX2 a b }; // :: WordX2

////

urem-Int32  = { a : Int32  => b : Int32  => prim urem-unsafe-Int32  a b };
urem-Int64  = { a : Int64  => b : Int64  => prim urem-unsafe-Int64  a b };
urem-Int8   = { a : Int8   => b : Int8   => prim urem-unsafe-Int8   a b };
urem-Word   = { a : Word   => b : Word   => prim urem-unsafe-Word   a b };
urem-WordX2 = { a : WordX2 => b : WordX2 => prim urem-unsafe-WordX2 a b };
udiv-Int32  = { a : Int32  => b : Int32  => prim udiv-unsafe-Int32  a b };
udiv-Int64  = { a : Int64  => b : Int64  => prim udiv-unsafe-Int64  a b };
udiv-Int8   = { a : Int8   => b : Int8   => prim udiv-unsafe-Int8   a b };
udiv-Word   = { a : Word   => b : Word   => prim udiv-unsafe-Word   a b };
udiv-WordX2 = { a : WordX2 => b : WordX2 => prim udiv-unsafe-WordX2 a b };
srem-Int32  = { a : Int32  => b : Int32  => prim srem-unsafe-Int32  a b };
srem-Int64  = { a : Int64  => b : Int64  => prim srem-unsafe-Int64  a b };
srem-Int8   = { a : Int8   => b : Int8   => prim srem-unsafe-Int8   a b };
srem-Word   = { a : Word   => b : Word   => prim srem-unsafe-Word   a b };
srem-WordX2 = { a : WordX2 => b : WordX2 => prim srem-unsafe-WordX2 a b };
sdiv-Int32  = { a : Int32  => b : Int32  => prim sdiv-unsafe-Int32  a b };
sdiv-Int64  = { a : Int64  => b : Int64  => prim sdiv-unsafe-Int64  a b };
sdiv-Int8   = { a : Int8   => b : Int8   => prim sdiv-unsafe-Int8   a b };
sdiv-Word   = { a : Word   => b : Word   => prim sdiv-unsafe-Word   a b };
sdiv-WordX2 = { a : WordX2 => b : WordX2 => prim sdiv-unsafe-WordX2 a b };
