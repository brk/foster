snafuinclude List "list";

// TODO switching from Boxed to Type fails...
type case Maybe (a:Boxed)
  of $None
  of $Some a
;

/////

bytesConcatByCopy = { a : Array Int8 => alen : Int32 =>
                      b : Array Int8 => blen : Int32 => len : Int32 =>
  if blen ==Int32 0 then a else
  // We do this somewhat-unsatisfactory dance of allocating a (mutable) array,
  // then filling its contents in via an exposed memcpy primitive.
  // It would be nicer to have (byte-)array concatenation be a primitive of the
  // runtime, but that would require the compiler to statically provide the
  // runtime with the typeinfo needed to call memalloc_array.
  //
  // It's also not great that using this in a loop gives O(n^2) asympotic
  // complexity rather than O(n), because we don't over-allocate our arrays.
  let bytes = allocDArray len; in
      // bytes[0..whatever]    = a[0..alen]
      memcpy_i8_to_from_at_len bytes a 0    alen;
      // bytes[alen..whatever] = b[0..blen]
      memcpy_i8_to_from_at_len bytes b alen blen;
      bytes
  end
  end
};

both = { a : Bool => b : Bool =>
  if a then b else False end
};

mkTextConcat = { a : Text => b : Text =>
  let lensum = (textLength a) +Int32 (textLength b);
       small = 120; // we'll be willing to memcpy buffers smaller than this.
  in
    case (a, b)
      of ($TextFragment ba na, $TextFragment bb nb) ->
        // One optimization from the paper "Ropes: an alternative to strings":
        // transparently flatten concatenations of small leaf nodes.
        if lensum <=SInt32 small
        then TextFragment (bytesConcatByCopy ba na bb nb lensum) lensum
        else TextConcat a b lensum
        end
      // Un-implemented optimizations: perform similar flattening for
      // ($TextConcat a ($TextFragment ab na) _, $TextFragment bb nb) ->
      // and
      // ($TextFragment ba na, $TextConcat ($TextFragment bb nb) c) ->
      of (_                  , _) ->
        TextConcat a b lensum
    end
  end
};

textLength = { t : Text =>
  case t
    of $TextFragment _ n -> n
    of $TextConcat _ _ n -> n
   end;
};

expect_text_bare = { s : Text =>
  case s
    of $TextFragment a n     -> prim_print_bytes_stderr a n; n
    of $TextConcat   s1 s2 n -> expect_text_bare s1; expect_text_bare s2; n
   end;
};

print_text_bare = { s : Text =>
  case s
    of $TextFragment a n     -> prim_print_bytes_stdout a n; n
    of $TextConcat   s1 s2 n -> print_text_bare s1; print_text_bare s2; n
   end;
};

expect_text = { s : Text =>
  expect_text_bare s; expect_newline !; ()
};

print_text = { s : Text =>
  print_text_bare s; print_newline !; ()
};

max-Int32 = { n : Int32 => m : Int32 => if n <SInt32 m then m else n end };

text_maxdepth = { s : Text =>
  case s
    of $TextFragment a n     -> 0
    of $TextConcat   s1 s2 n -> 1 +Int32
                               (max-Int32 (text_maxdepth s1) (text_maxdepth s2))
   end;
};

// Precondition: n in range 0..128.
textOfASCII = { n : Int32 => textOfASCII8 (primitive_trunc_i32_i8 n) };

// Precondition: n in range 0..128.
textOfASCII8 = { n : Int8 =>
  let a = newDArray:[Int8] 1 { i => n };
  in
    TextFragment a 1
  end
};

////

arrayLength :: forall x:Type, { Array x => Int64 };
arrayLength = { forall t:Type, a : Array t =>
  prim_arrayLength a
};

arrayLength32 :: forall x:Type, { Array x => Int32 };
arrayLength32 = { forall t:Type, a : Array t =>
  primitive_trunc_i64_i32 (prim_arrayLength a)
};


incr64 = { n : Int64 => n +Int64 (primitive_sext_i64_i32 1) };

arrayEnumFrom = { forall t:Type,
                  a : Array t =>
                  k : Int64 =>
                  f : { t => Int64 => () } =>
  if k <SInt64 prim_arrayLength a
    then f a[primitive_trunc_i64_i32 k] k; arrayEnumFrom a (incr64 k) f
    else ()
  end
};

arrayEnum = { forall t:Type,
              a : Array t =>
              f : { t => Int64 => () } =>
  arrayEnumFrom a (primitive_sext_i64_i32 0) f
};

/*
arrayEach = { forall t:Type,
              a : Array t =>
              f : { t => () } =>
  arrayEnum a { ign:Int64 => v:t => f v };
};
*/

// Initializes slot a[k] with f (k + 1)
newDArray = { forall v:Type,
                n : Int32 =>
                f : { Int32 => v } =>
  let a = allocDArray:[v] n;
      x = (ref n);
   in
      until x^ ==Int32 0 then
          f x^      >^ a[x^ -Int32  1];
           (x^ -Int32 1) >^ x
      end;
    a
  end
};

// Initializes slot a[k] with (f k)
newDArray0 = { forall v:Type,
                n : Int32 =>
                f : { Int32 => v } =>
  let a = allocDArray:[v] n;
      x = (ref n);
   in
      until x^ ==Int32 0 then
        let y  = x^ -Int32 1; in
          (f y) >^ a[y];
             y  >^ x
        end
      end;
    a
  end
};

// Returns True on success, otherwise False.
arrayIterReverse = { forall t:Type,
                           a : Array t =>
                           n : Int32 => // invariant: n < len a
                           f : { t => Bool } =>
  if n >=SInt32 0 // TODO change this to avoid needing wraparound here.
  then if f a[n] then arrayIterReverse a (n -Int32 1) f
                 else False end
  else True end
};

////

// Returns True on success, otherwise False.
tmp_Text_bytes_iter_reverse = { t:Text =>
                                f: { Int8 => Bool } =>
  case t
    of $TextFragment a n     -> arrayIterReverse a (n -Int32 1) f;
    of $TextConcat   s1 s2 n ->
        if    tmp_Text_bytes_iter_reverse s2 f
         then tmp_Text_bytes_iter_reverse s1 f
         else False
        end
   end;
};

is_ascii_digit = { c : Int8 =>
  if   c <=SInt8 (primitive_trunc_i32_i8 57)
  then c >=SInt8 (primitive_trunc_i32_i8 48)
  else False
  end
};

tmp_Int32_of_base_10_Text = { t:Text =>
  let acc = (ref 0);
      pow = (ref 1);
      base = 10;
      ok = tmp_Text_bytes_iter_reverse t { c : Int8 =>
       //print_text "is_ascii_digit c:"; // hmm, causes crash...
       if is_ascii_digit c
         then
           let s = (primitive_sext_i8_to_i32 c) -Int32 48;
           in
             (acc^ +Int32 (s *Int32 pow^)) >^ acc;
             (pow^           *Int32 base ) >^ pow;
             True
           end
         else False
       end;
     };
  in
    if ok then acc^ else 0 end
  end
};

tmp_Text_of_Int32_digit = { n:Int32 =>
  case n
    of 0 -> "0"
    of 1 -> "1"
    of 2 -> "2"
    of 3 -> "3"
    of 4 -> "4"
    of 5 -> "5"
    of 6 -> "6"
    of 7 -> "7"
    of 8 -> "8"
    of 9 -> "9"
    of _ -> "<error:value passed to tmp_Text_of_Int32_digit was too large>"
  end
};

tmp_Text_16_of_Int32_digit = { n:Int32 =>
  case n
    of 0 -> "0"
    of 1 -> "1"
    of 2 -> "2"
    of 3 -> "3"
    of 4 -> "4"
    of 5 -> "5"
    of 6 -> "6"
    of 7 -> "7"
    of 8 -> "8"
    of 9 -> "9"
    of 10 -> "A"
    of 11 -> "B"
    of 12 -> "C"
    of 13 -> "D"
    of 14 -> "E"
    of 15 -> "F"
    of _ -> "<error:value passed to tmp_Text_16_of_Int32_digit was too large>"
  end
};

tmp_Text_of_Int32 = { n:Int32 => tmp_Text_of_Int64 (primitive_sext_i64_i32 n) };

tmp_Text_2_of_Int8_nibble = { n : Int8 =>
  case n
    of 0  -> "0000"
    of 1  -> "0001"
    of 2  -> "0010"
    of 3  -> "0011"
    of 4  -> "0100"
    of 5  -> "0101"
    of 6  -> "0110"
    of 7  -> "0111"
    of 8  -> "1000"
    of 9  -> "1001"
    of 10 -> "1010"
    of 11 -> "1011"
    of 12 -> "1100"
    of 13 -> "1101"
    of 14 -> "1110"
    of 15 -> "1111"
    of _ -> "<error:value passed to tmp_Text_2_of_Int8_nibble was too large>"
  end
};

tmp_Text_2_of_Int8 = { n:Int8 =>
  mkTextConcat (tmp_Text_2_of_Int8_nibble (bitand-Int8 15 (bitlshr-Int8 n 4)))
 (mkTextConcat (tmp_Text_2_of_Int8_nibble (bitand-Int8 15 n))
  "");
};

tmp_Text_2_of_Int32 = { n:Int32 =>
  let go = { n:Int32 =>
    let n0 = primitive_trunc_i32_i8 n;
        n1 = primitive_trunc_i32_i8 (bitlshr-Int32 n 8 );
        n2 = primitive_trunc_i32_i8 (bitlshr-Int32 n 16);
        n3 = primitive_trunc_i32_i8 (bitlshr-Int32 n 24);
    in
     mkTextConcat (tmp_Text_2_of_Int8 n3)
    (mkTextConcat (tmp_Text_2_of_Int8 n2)
    (mkTextConcat (tmp_Text_2_of_Int8 n1)
    (mkTextConcat (tmp_Text_2_of_Int8 n0) "")))
   end
  }; in if n <SInt32 0 then mkTextConcat "-" (go (0 -Int32 n))
                      else go n
        end
  end
};

high32BitsOf64 = { n : Int64 =>
  primitive_trunc_i64_i32 (bitlshr-Int64 n 32)
};

splitInt64 = { n : Int64 =>
  let highbits = high32BitsOf64 n;
      lowbits  = high32BitsOf64 (bitshl-Int64 n 32);
   in (highbits, lowbits) end
};

tmp_Text_2_of_Int64 = { n:Int64 =>
  case splitInt64 n of
    (na, nb) ->
      mkTextConcat (tmp_Text_2_of_Int32 na) (tmp_Text_2_of_Int32 nb)
  end
};

tmp_Text_of_Int64 = { n:Int64 =>
  rec go = { n:Int64 => t:Text =>
    if n <=SInt64 10
      then mkTextConcat (tmp_Text_of_Int32_digit (primitive_trunc_i64_i32 n)) t
      else let r = primitive_trunc_i64_i32 (srem-Int64 n 10);
               q =                          sdiv-Int64 n 10 ;
            in go q (mkTextConcat (tmp_Text_of_Int32_digit r) t); end
     end
  }; in if n <SInt64 0 then mkTextConcat "-" (go (negate-Int64 n) "")
                      else go n ""
        end
  end
};


