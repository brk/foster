snafuinclude List "list";

// TODO switching from Boxed to Type fails...
type case Maybe (a:Boxed)
  of $None
  of $Some a
;

/////

bytesConcatByCopy = { a : Array Int8 => alen : Int32 =>
                      b : Array Int8 => blen : Int32 => len : Int32 =>
  if blen ==Int32 0 then a else
  // We do this somewhat-unsatisfactory dance of allocating a (mutable) array,
  // then filling its contents in via an exposed memcpy primitive.
  // It would be nicer to have (byte-)array concatenation be a primitive of the
  // runtime, but that would require the compiler to statically provide the
  // runtime with the typeinfo needed to call memalloc_array.
  //
  // It's also not great that using this in a loop gives O(n^2) asympotic
  // complexity rather than O(n), because we don't over-allocate our arrays.
  let bytes = allocDArray len; in
      // bytes[0..whatever]    = a[0..alen]
      memcpy_i8_to_from_at_len bytes a 0    alen;
      // bytes[alen..whatever] = b[0..blen]
      memcpy_i8_to_from_at_len bytes b alen blen;
      bytes
  end
  end
};

both = { a : Bool => b : Bool =>
  if a then b else False end
};

mkTextConcat = { a : Text => b : Text =>
  let lensum = (textLength a) +Int32 (textLength b);
       small = 120; // we'll be willing to memcpy buffers smaller than this.
  in
    case (a, b)
      of ($TextFragment ba na, $TextFragment bb nb) ->
        // One optimization from the paper "Ropes: an alternative to strings":
        // transparently flatten concatenations of small leaf nodes.
        if lensum <=Int32 small
        then TextFragment (bytesConcatByCopy ba na bb nb lensum) lensum
        else TextConcat a b lensum
        end
      // Un-implemented optimizations: perform similar flattening for
      // ($TextConcat a ($TextFragment ab na) _, $TextFragment bb nb) ->
      // and
      // ($TextFragment ba na, $TextConcat ($TextFragment bb nb) c) ->
      of (_                  , _) ->
        TextConcat a b lensum
    end
  end
};

textLength = { t : Text =>
  case t
    of $TextFragment _ n -> n
    of $TextConcat _ _ n -> n
   end;
};

expect_text_bare = { s : Text =>
  case s
    of $TextFragment a n     -> prim_print_bytes_stderr a n; n
    of $TextConcat   s1 s2 n -> expect_text_bare s1; expect_text_bare s2; n
   end;
};

print_text_bare = { s : Text =>
  case s
    of $TextFragment a n     -> prim_print_bytes_stdout a n; n
    of $TextConcat   s1 s2 n -> print_text_bare s1; print_text_bare s2; n
   end;
};

expect_text = { s : Text =>
  expect_text_bare s; expect_newline !; ()
};

print_text = { s : Text =>
  print_text_bare s; print_newline !; ()
};

max-Int32 = { n : Int32 => m : Int32 => if n <Int32 m then m else n end };

text_maxdepth = { s : Text =>
  case s
    of $TextFragment a n     -> 0
    of $TextConcat   s1 s2 n -> 1 +Int32
                               (max-Int32 (text_maxdepth s1) (text_maxdepth s2))
   end;
};

////

arrayLength :: forall x:Type, { Array x => Int64 };
// TODO we currently fail to unify the two type variables here:
arrayLength = { forall t:Type, a : Array t => prim_arrayLength a };

incr64 = { n : Int64 => n +Int64 (primitive_sext_i64_i32 1) };

arrayEnumFrom = { forall t:Type,
                  a : Array t =>
                  k : Int64 =>
                  f : { t => Int64 => () } =>
  if k <Int64 prim_arrayLength a
    then f a[primitive_trunc_i64_i32 k] k; arrayEnumFrom a (incr64 k) f
    else ()
  end
};

arrayEnum = { forall t:Type,
              a : Array t =>
              f : { t => Int64 => () } =>
  arrayEnumFrom a (primitive_sext_i64_i32 0) f
};

/*
arrayEach = { forall t:Type,
              a : Array t =>
              f : { t => () } =>
  arrayEnum a { ign:Int64 => v:t => f v };
};
*/

////

// Returns True on success, otherwise False.
tmp_bytes_iter_reverse = { a : Array Int8 =>
                           n : Int32 => // invariant: n < len a
                           f : { Int8 => Bool } =>
  if n >=Int32 0
  then if f a[n] then tmp_bytes_iter_reverse a (n -Int32 1) f
                 else False end
  else True end
};

// Returns True on success, otherwise False.
tmp_Text_bytes_iter_reverse = { t:Text =>
                                f: { Int8 => Bool } =>
  case t
    of $TextFragment a n     -> tmp_bytes_iter_reverse a (n -Int32 1) f;
    of $TextConcat   s1 s2 n ->
        if    tmp_Text_bytes_iter_reverse s2 f
         then tmp_Text_bytes_iter_reverse s1 f
         else False
        end
   end;
};

is_ascii_digit = { c : Int8 =>
  if   c <=Int8 (primitive_trunc_i32_i8 57)
  then c >=Int8 (primitive_trunc_i32_i8 48)
  else False
  end
};

tmp_Int32_of_base_10_Text = { t:Text =>
  let acc = (ref 0);
      pow = (ref 1);
      base = 10;
      ok = tmp_Text_bytes_iter_reverse t { c : Int8 =>
       //print_text "is_ascii_digit c:"; // hmm, causes crash...
       if is_ascii_digit c
         then
           let s = (primitive_sext_i8_to_i32 c) -Int32 48;
           in
             (acc^ +Int32 (s *Int32 pow^)) >^ acc;
             (pow^           *Int32 base ) >^ pow;
             True
           end
         else False
       end;
     };
  in
    if ok then acc^ else 0 end
  end
};

tmp_Text_of_Int32_digit = { n:Int32 =>
  case n
    of 0 -> "0"
    of 1 -> "1"
    of 2 -> "2"
    of 3 -> "3"
    of 4 -> "4"
    of 5 -> "5"
    of 6 -> "6"
    of 7 -> "7"
    of 8 -> "8"
    of 9 -> "9"
    of _ -> "<error:value passed to tmp_Text_of_Int32_digit was too large>"
  end
};

tmp_Text_of_Int32 = { n:Int32 =>
  rec go = { n:Int32 => t:Text =>
    if n <=Int32 10
      then mkTextConcat (tmp_Text_of_Int32_digit n) t
      else let r = srem-Int32 n 10;
               q = sdiv-Int32 n 10;
            in go q (mkTextConcat (tmp_Text_of_Int32_digit r) t); end
     end
  }; in if n <=Int32 0 then mkTextConcat "-" (go (0 -Int32 n) "")
                       else go n ""
        end
  end
};

