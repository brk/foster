snafuinclude Prelude "prelude";

type case Field (a:Type)
  of $Field (Ref a)
;

mkField :: forall (a:Type) { a => Field a };
mkField = { v => Field (prim ref v) };

getField :: forall (a:Type) { Field a => a };
getField = { f => case f of $Field a -> a^ end };


type case Ptr (a:Type)
  of $PtrNil
  of $PtrArr (Array a) Int32
  of $PtrRef (Ref a)
  ;

ptrGetIndex :: forall (a:Type) { Ptr a => Int32 => a };
ptrGetIndex = { ptr => idx =>
  case ptr
    of $PtrNil -> prim kill-entire-process "ptrGetIndex null";
    of $PtrRef r -> r^
    of $PtrArr arr off -> arr[off +Int32 idx]
  end
};

ptrSetIndex :: forall (a:Type) { Ptr a => Int32 => a => () };
ptrSetIndex = { ptr => idx => val =>
  case ptr
    of $PtrNil -> ()
    of $PtrRef r -> val >^ r;
    of $PtrArr arr off -> val >^ arr[off +Int32 idx];
  end
};

ptrGet :: forall (a:Type) { Ptr a => a };
ptrGet = { ptr =>
  case ptr
    of $PtrNil -> prim kill-entire-process "ptrGet null";
    of $PtrRef r -> r^
    of $PtrArr arr off -> arr[off]
  end
};

ptrSet :: forall (a:Type) { Ptr a => a => () };
ptrSet = { ptr => val =>
  case ptr
    of $PtrNil -> prim kill-entire-process "ptrGet null";
    of $PtrRef r -> val >^ r;
    of $PtrArr arr off -> val >^ arr[off]
  end
};

ptrPlus :: forall (a:Type) { Ptr a => Int32 => Ptr a };
ptrPlus = { ptr => n =>
  case ptr
    of $PtrNil   -> ptr
    of $PtrRef r -> ptr
    of $PtrArr arr off -> PtrArr arr (off +Int32 n)
  end
};

ptrMinus :: forall (a:Type) { Ptr a => Int32 => Ptr a };
ptrMinus = { ptr => n =>
  case ptr
    of $PtrNil   -> ptr
    of $PtrRef r -> ptr
    of $PtrArr arr off -> PtrArr arr (off -Int32 n)
  end
};

ptrMemset :: forall (a:Type) { Ptr a => a => Int32 => () };
ptrMemset = { ptr => v => n =>
  enumRange32 0 n { i => ptrSetIndex ptr i v };
};

ptrMemcpy :: forall (a:Type) { Ptr a => Ptr a => Int32 => () };
ptrMemcpy = { dst => src => n =>
  enumRange32 0 n { i => ptrSetIndex dst i (ptrGetIndex src i) };
};

ptrStrlen :: { Ptr Int8 => Int64 };
ptrStrlen = { ptr =>
  REC go = { i =>
    if ptrGetIndex ptr i ==Int8 0
      then i |> zext_i32_to_i64
      else go (i +Int32 1)
    end
  };
  go 0
};

ptrMemcmp :: forall (a:Type) { Ptr a => Ptr a => Int32 => { a => a => Ord } => Int32 };
ptrMemcmp = { a => b => n => cmp =>
  REC go = { i =>
    if i <UInt32 n then
      case ptrGetIndex a i `cmp` ptrGetIndex b i
        of EQ -> go (i +Int32 1)
        of LT -> -1
        of GT ->  1
      end
    else
      0
    end
  };
  go 0;
};


incr_Ptr_Int8_     = { r : Ref (Ptr Int8) => v = (r^ `ptrPlus` 1); v >^ r; v };
decr_Ptr_Int8_     = { r : Ref (Ptr Int8) => v = (r^ `ptrMinus` 1); v >^ r; v };
postincr_Ptr_Int8_ = { r : Ref (Ptr Int8) => v = r^; (v `ptrPlus` 1) >^ r; v };
postdecr_Ptr_Int8_ = { r : Ref (Ptr Int8) => v = r^; (v `ptrMinus` 1) >^ r; v };

strLit :: forall (t:Type) { Array t => Ptr t };
strLit = { s => PtrArr s 0 };

printStr :: { Ptr Int8 => () };
printStr = { ptr =>
  case ptr
    of $PtrNil   -> print_text "(null)";
    of $PtrRef r -> print_text "PtrRef";
    of $PtrArr arr off ->
        len = arrayLength32 arr -Int32 (off +Int32 1);
        prim_print_bytes_stdout arr len off;
        print_newline !;
  end
};


type case ArrPtr (a:Type)
  of $ArrPtr (Array a) Int64
  ;

incrArrPtr :: forall (a:Type) { ArrPtr a => ArrPtr a };
incrArrPtr = { v => case v of $ArrPtr a x -> ArrPtr a (x +Int64 1) end };
