snafuinclude Prelude "prelude";

type case IntInf
      of $IntInf (Array Int64) Bool
      ;

// Invariant on (IntInf a _):   used a >= 1.

// TODO use the LLVM's -with-overflow intrinsics to
// enable use of the full 64 bits for the digit value.

type case Ord
       of $LT
       of $EQ
       of $GT
       ;

notBool = { a:Bool => if a then False else True end };
eqBool = { a:Bool => b:Bool => if a then b else notBool b end };

digits :: { IntInf => Array Int64 };
digits = {  i      =>
  case i
    of $IntInf a _ -> a
  end
};

isNegative :: { IntInf => Bool };
isNegative = {  i      =>
  case i
    of $IntInf _ n -> n
  end
};

used :: { Array Int64 => Int32 };
used = { a =>
  arrayLength32 a  // just array size, since we don't over-allocate.
};

//foster_MP_MASK = ...;
// need 'global' constants

ordInvert = { b : Ord =>
  case b
    of $LT -> GT !
    of $GT -> LT !
    of _   -> b
  end
};

ordInvertIf = { b : Ord => cnd : Bool =>
  if cnd then ordInvert b else b end
};

cmpInt32 = { a : Int32 => b : Int32 =>
  if a ==Int32 b
  then EQ !
  else if a <Int32 b then LT ! else GT ! end
  end
};

cmpInt64 = { a : Int64 => b : Int64 =>
  if a ==Int64 b
  then EQ !
  else if a <Int64 b then LT ! else GT ! end
  end
};

textOfOrd = { o : Ord =>
  case o
    of $LT -> "LT"
    of $EQ -> "EQ"
    of $GT -> "GT"
  end
};

findFirstUsedDigit = { a : Array Int64 =>
  rec go = { k =>
     if k <Int32 0 then 0 else
         if a[k] !=Int64 0
             then k
             else go (k -Int32 1)
         end
     end
           };
  in go (used a -Int32 1) end;
};

// Precondition: b & MP_DIGIT_MASK == b
//
cmpIntInfAbsDigitsD = { a : Array Int64 => b : Int64 =>
  if used a >Int32 1
    then
         // Because we don't yet use all 64 bits of each word,
         // a 62-bit or 63-bit number needs two limbs to represent.
         //
         // We can (and eventually plan to) fix this by using LLVM's
         // overflow-reflecting intrinsics to use all 64 bits.
         //
         if used a ==Int32 2
           then cmpIntInfAbs a (mkDigitsOfInt64 b)
           else GT !
         end
    else cmpInt64 a[0] b
  end
};

cmpIntInfAbsD = { a : IntInf => b : Int64 =>
  cmpIntInfAbsDigitsD (digits a) b
};

cmpIntInfD = { a : IntInf => b : Int64 =>
  case (isNegative a, b <Int64 0)
    of (True, False) -> LT !
    of (False, True) -> GT !
    of (False,False) -> cmpIntInfAbsDigitsD (digits a) b
    of (True , True) ->
      case cmpIntInfAbsDigitsD (digits a) (negate-Int64 b)
        of $EQ -> EQ !
        of c   -> ordInvert c
      end
  end
};

cmpIntInfAbs = { a : Array Int64 => b : Array Int64 =>
  let a_first_used = findFirstUsedDigit a;
      b_first_used = findFirstUsedDigit b;
      cmpord = cmpInt32 a_first_used b_first_used;
  in
    case cmpord
      of $LT -> cmpord
      of $GT -> cmpord
      of _ ->
        rec go = { k =>
                    let cmpord = cmpInt64 a[k] b[k]; in
                      if k ==Int32 0 then cmpord
                      else
                        case cmpord
                          of $LT -> cmpord
                          of $GT -> cmpord
                          of _   -> go (k -Int32 1)
                        end
                      end
                    end
                 };
       in
          if used a ==Int32 0 then EQ ! else
            go a_first_used
          end
       end
     end
  end
};

foster_mp_cmp = { x : IntInf => y:IntInf =>
  case (isNegative x, isNegative y)
    of (True, False) -> LT !
    of (False, True) -> GT !
    of (xneg , _   ) ->
      if xneg
        then cmpIntInfAbs (digits y) (digits x)
        else cmpIntInfAbs (digits x) (digits y)
      end
  end
};

// Precondition: fst <= fin
//
foldRange = { forall t:Type,
              fst : Int32 =>
              fin : Int32 =>
              init : t =>
              iter : { Int32 => t => t } =>
  rec go =  { n : Int32 => acc : t =>
                if n >=Int32 fin then acc else
                  go (n +Int32 1) (iter n acc)
                end
            };
  in go fst init end
};

// Precondition: fst >= fin
//
foldRangeDown = { forall t:Type,
              fst : Int32 =>
              fin : Int32 =>
              init : t =>
              iter : { Int32 => t => t } =>
  rec go =  { n : Int32 => acc : t =>
                if n >=Int32 fin then
                  go (n -Int32 1) (iter n acc)
                else acc end
            };
  in go fst init end
};

// foster_DIGIT_BIT = 60
// foster_MP_DIGIT_BIT_MASK = (1 << foster_DIGIT_BIT) - 1
// foster_MP_DIGIT_BIT_MASK = FFF`FFFF`FFFF`FFFF_16

addCarryOf :: { Int64 => Int64 };
addCarryOf = { n =>
  bitlshr-Int64 n 60
  // shift right (>>) by foster_MP_DIGIT_BIT = 60 for i64
};

subCarryOf :: { Int64 => Int64 };
subCarryOf = { n =>
  bitlshr-Int64 n 63
  // shift right (>>) by foster_MP_SIGN_BITSHIFT = 63 for i64
};

foster_mp_isZero_nat = { a : Array Int64 =>
  if used a ==Int32 0 then True else
    arrayIterReverse a (used a -Int32 1) { v : Int64 =>
      v ==Int64 0
    };
  end
};

mkIntInf :: { Array Int64 => Bool => IntInf };
mkIntInf = { a => isNeg =>
  if foster_mp_isZero_nat a then IntInf a False
                     else IntInf a isNeg
  end
};

copyOfArrayTo :: { Array Int64 => // of length m
                   /*n:*/Int32 =>
                   Array Int64    // of length n
                 };
copyOfArrayTo =  { a => n =>
  newDArray:[Int64] n { i : Int32 => a[i -Int32 1] };
};

trimLeadingZeros :: { Array Int64 => Array Int64 };
trimLeadingZeros = { a =>
  rec findFirstNonZero = { n : Int32 =>
         if n ==Int32 0 // or a[n] !=Int64 0
           then n
           else if a[n] !=Int64 0
                  then n
                  else findFirstNonZero (n -Int32 1)
                end
         end
      };
  in
    let start = used a -Int32 1;
        n = findFirstNonZero start;
    in
       if n ==Int32 start
         then a
         else copyOfArrayTo a (n +Int32 1)
       end
    end
  end
};

foster_mp_add :: {  IntInf =>   IntInf => IntInf };
foster_mp_add = { a:IntInf => b:IntInf =>

    if eqBool (isNegative a) (isNegative b)
      then             mkIntInf (foster_mp_add_UA (digits a) (digits b)) (isNegative a)
      else case cmpIntInfAbs (digits a) (digits b)
             of $LT -> mkIntInf (foster_mp_sub_UA (digits b) (digits a)) (isNegative b)
             of _   -> mkIntInf (foster_mp_sub_UA (digits a) (digits b)) (isNegative a)
           end
    end

};


foster_mp_sub :: {  IntInf =>   IntInf => IntInf };
foster_mp_sub = { a:IntInf => b:IntInf =>

    if eqBool (isNegative a) (isNegative b)
      then case cmpIntInfAbs (digits a) (digits b) // interesting bug if non-abs comparison is used.
             of $LT -> // if b > a, then +a - +b = -(b - a), and (-a - -b) = (+)(b - a).
                       mkIntInf (foster_mp_sub_UA (digits b) (digits a)) (not (isNegative a))
             of _   -> mkIntInf (foster_mp_sub_UA (digits a) (digits b)) (isNegative a)
                       // if a >= b,then +a - +b = (+)(a - b), and (-a - -b) = -(a - b).
           end
      else // -a - b = -(a + b), and a - -b = (+)(a + b)
                       mkIntInf (foster_mp_add_UA (digits a) (digits b)) (isNegative a)
    end

};

foster_mp_add_UA :: { Array Int64 => Array Int64 => Array Int64 };
foster_mp_add_UA = { a => b =>
let foster_MP_MASK = 0FFF`FFFF`FFFF`FFFF_16;
in
  case
    if (used a) <Int32 (used b)
      then (a, b)
      else (b, a)
    end
  of (sm, lg) ->

    let c = allocDArray:[Int64] (used lg +Int32 1);
        u = foldRange 0 (used sm) 0 { i => u =>
            (a[i] +Int64 b[i] +Int64 u) >^ c[i];
            let unext = addCarryOf c[i];
            in
              (bitand-Int64 c[i] foster_MP_MASK) >^ c[i];
              unext
            end
          };
        p = if used sm <Int32 used lg
              then
                foldRange (used sm) (used lg) u { i => u =>
                  (lg[i] +Int64 u) >^ c[i];
                  let unext = addCarryOf c[i];
                  in
                    (bitand-Int64 c[i] foster_MP_MASK) >^ c[i];
                    unext
                  end
                }
              else
                u
            end;
    in
      p >^ c[used lg];

      // The C version clears digits from used to olduse,
      // but we don't need to because we allocate from scratch.

      trimLeadingZeros c
    end;
  end
end
};

// Precondition: |lg| > |sm|
foster_mp_sub_UA :: { Array Int64 => Array Int64 => Array Int64 };
foster_mp_sub_UA = { lg => sm =>
 let foster_MP_MASK = 0FFF`FFFF`FFFF`FFFF_16;
 in
    let c = allocDArray:[Int64] (used lg);
        u = foldRange 0 (used sm) 0 { i => u =>
              let ci = lg[i] -Int64 sm[i] -Int64 u; in
                (bitand-Int64 ci foster_MP_MASK) >^ c[i];
                subCarryOf ci
              end
            };
        p = foldRange (used sm) (used lg) u { i => u =>
              let ci = lg[i] -Int64 u; in
                (bitand-Int64 ci foster_MP_MASK) >^ c[i];
                subCarryOf ci
              end
            };
    in
      // The C version clears digits from used to olduse,
      // but we don't need to because we allocate from scratch.

      trimLeadingZeros c
    end;
  end
};

// Left shift by n digits.
//
// Precondition:
//      |a| + n does not overflow
//      |a| + n <= |res|
//            n > 0
foster_mp_lshd_to :: { Array Int64 => Int32 => Array Int64 => () };
foster_mp_lshd_to = { a => n => res =>
  // TODO memcpy?
  // Fill in the top digits:
  arrayEnum a { e : Int64 => ik : Int64 =>
    e >^ res[primitive_trunc_i64_i32 ik +Int32 n];
    // It's safe to compute i + n without checking for overflow,
    // because i <= arraySize a and n + i cannot overflow if
    //                   i <= k and n + k cannot oveflow.
  };
  // Zero out the bottom digits:
  foldRange 0 n () { k:Int32 => unit => 0 >^ res[k]; unit };
};

// Precondition:
//      |a| == |res|
foster_mp_copy_to :: { Array Int64 => Array Int64 => () };
foster_mp_copy_to = { a => res =>
  arrayEnum a { e : Int64 => ik : Int64 =>
    e >^ res[primitive_trunc_i64_i32 ik];
    // It's safe to compute i + n without checking for overflow,
    // because i <= arraySize a and n + i cannot overflow if
    //                   i <= k and n + k cannot oveflow.
  };
};
// TODO: can we guarantee generation of (foster_mp_copy_to a b)'s code
//       by optimizing (foster_mp_lshd_to a 0 b)?

foster_mp_lshd_UA :: { Array Int64 => Int32 => Array Int64 };
foster_mp_lshd_UA = { a => n =>
  if n <=Int32 0 then a else
    // TODO assert that n + arraySize a does not overflow...
    let r = allocDArray:[Int64] (n +Int32 used a);
    in
      foster_mp_lshd_to a n r;
      r
    end
  end
};


// Left shift by k bits.
//
foster_mp_mul_2d :: { IntInf => Int32 => IntInf };
foster_mp_mul_2d = { i => k =>
  case i of
     $IntInf a n -> IntInf (foster_mp_mul_2d_UA a k) n
  end
};

// Precondition: 0 <= n < 64
//
foster_mp_mul_2d_UA :: { Array Int64 => Int32 => Array Int64 };
foster_mp_mul_2d_UA = { a => n =>
    // TODO assert that (slop + used a) does not overflow...
    let foster_DIGIT_BIT = 60;
        by_digits = sdiv-Int32 n foster_DIGIT_BIT;
        sz        = by_digits +Int32 used a;
        r         = allocDArray:[Int64] (sz +Int32 1);
        d         = srem-Int32 n foster_DIGIT_BIT;
    in
      0 >^ r[sz]; // zero out the slop digit.

      // Step 0:          [////|////|////|////] (a)
      //
      // Step 1b: [00|0000|0000|0000|0000|0000] (r allocated)
      // Step 1b: [00|////|////|////|////|0000] (r gets a, shifted left)
      //
      // Step 2n: [//|////|////|////|//00|0000] (after intra-digit shifting)

      /*
      print_text "by_digits";
      print_i32   by_digits;
      print_text "d";
      print_i32   d;
      */

      if by_digits >Int32 0
        then foster_mp_lshd_to a by_digits r
        else foster_mp_copy_to a           r
      end;

      if d ==Int32 0 then () else
        let //mask32  = (bitshl-Int32 1 d) -Int32 1; // buggy (for d=32)
            //mask64  = primitive_sext_i64_i32 mask32;

            d64     = primitive_sext_i64_i32 d;
            mask64  = (bitshl-Int64 1 d64) -Int64 1;
            shift32 = foster_DIGIT_BIT -Int32 d;

            shift64 = primitive_sext_i64_i32 shift32;

            foster_MP_MASK = 0FFF`FFFF`FFFF`FFFF_16;

            carry = foldRange 0 (used r -Int32 1) 0 { i => u =>
                      let rr = bitand-Int64 mask64
                              (bitlshr-Int64 r[i] shift64);
                          v =  bitand-Int64 foster_MP_MASK
                              (bitor-Int64 u
                              (bitshl-Int64 r[i] d64));
                      in
                      /*
                          print_text "v";
                          print_i64b  v;
                          print_text "foster_MP_MASK";
                          print_i64b  foster_MP_MASK;
                          print_text "bitlshr-Int64 r[i] shift64";
                          print_i64b (bitlshr-Int64 r[i] shift64);
                          print_text "mask64";
                          print_i64b  mask64;
                          print_text "shift64";
                          print_i64   shift64;
                          print_text "r[i]";
                          print_i64b  r[i];
                          print_text "d64";
                          print_i64   d64;
                          print_text "rr";
                          print_i64b  rr;
                       */
                          v >^ r[i];
                          rr
                      end
                    };
        in
        /*
           print_text "carry";
           print_i64b  carry;
        */
           if carry !=Int64 0
             then carry >^ r[used r -Int32 1];
             else ()
           end
        end
      end;

      trimLeadingZeros r
    end
};

mkDigitsOfInt32 :: { Int32 => Array Int64 };
mkDigitsOfInt32 = { k =>
  newDArray 1 { ignore => primitive_zext_i32_to_i64 k }
};

foster_mp_from_Int32 :: { Int32 => IntInf };
foster_mp_from_Int32 = { k =>
  if k <Int32 0
    then IntInf (mkDigitsOfInt32 (negate-Int32 k)) True
    else IntInf (mkDigitsOfInt32 k) False
  end
  // OK not to use mkIntInf here because we're preserving IntInf's invariants.
};

mkDigitsOfInt64 :: { Int64 => Array Int64 };
mkDigitsOfInt64 = { k =>
  case splitInt64 k
    of (hi, lo) ->
      let ahi = mkDigitsOfInt32 hi;
          alo = mkDigitsOfInt32 lo;
      in
        trimLeadingZeros (foster_mp_add_UA (foster_mp_mul_2d_UA ahi 32) alo)
      end
  end
};

// Precondition: k >= 0
foster_mp_from_Int64 :: { Int64 => IntInf };
foster_mp_from_Int64 = { k =>
  if k <Int64 0
    then IntInf (mkDigitsOfInt64 (negate-Int64 k)) True
    else IntInf (mkDigitsOfInt64 k) False
  end
  // OK not to use mkIntInf here because we're preserving IntInf's invariants.
};

bitlength-Int64 :: { Int64 => Int32 };
bitlength-Int64 = { k =>
  rec go = { x => acc =>
                 if x ==Int64 0
                   then acc
                   else go (bitlshr-Int64 k 1) (acc +Int32 1)
                 end
           };
  in
    go k 0
  end
};

foster_mp_bitlength :: { IntInf => Int32 };
foster_mp_bitlength = { i =>
  let foster_DIGIT_BIT = 60;
      a = digits i;
      r0 = (used a -Int32 1) *Int32 foster_DIGIT_BIT;
  in
      r0 +Int32 (bitlength-Int64 a[used a -Int32 1]);
  end;
};


foster_mp_unsigned_bin_size :: { IntInf => Int32 };
foster_mp_unsigned_bin_size = { i =>
  let size = foster_mp_bitlength i;
      extra_bit = if (bitand-Int32 size 7) ==Int32 0 then 0 else 1 end;
  in
    (sdiv-Int32 size 8) +Int32 extra_bit
  end
};

// Returns ( quo=floor(i/b) , rem=i-quo*b )
//
// Precondition: b != 0
// Precondition: b != 1
foster_mp_div_nat_digit_nz :: { Array Int64 => Int64 => (Array Int64, Int64) };
foster_mp_div_nat_digit_nz = { a => b =>
  // TODO special handling for b=3, b power of 2...

  let foster_DIGIT_BIT = 60;
      q         = allocDArray:[Int64] (used a);
      remainder = foldRangeDown (used a -Int32 1) 0 0 { k32 => w0 =>
                    let w = bitor-Int64 a[k32]
                               (bitshl-Int64 w0 foster_DIGIT_BIT);
                        wb = w >=UInt64 b;
                        t  = if wb then udiv-Int64 w b else 0 end;
                    in
                    /*
                        print_text "init q at index:";
                        print_i32 k32;

                        print_text "with a[k]:";
                        print_i64b a[k32];

                        print_text "with w0:";
                        print_i64b w0;

                        print_text "with w:";
                        print_i64b w;

                        print_text "with t:";
                        print_i64b t;
*/
                        t >^ q[k32];

/*
                                   print_text "w;t;b;t*b;w-t*b";
                                   print_i64 w;
                                   print_i64 t;
                                   print_i64 b;
                                   print_i64 (t *Int64 b);
                                   print_i64 (w -Int64 (t *Int64 b));
*/

                        if wb then
                                   w -Int64 (t *Int64 b)
                              else w
                        end
                    end
                  };
  in
     //print_text "remainder:";
     //print_i64   remainder;
     (trimLeadingZeros q, remainder)
  end
};

// Returns ( quo=floor(i/b) , rem=i-quo*b )
//
// Precondition: b != 0
// Precondition: b != 1
foster_mp_div_digit_nz :: { IntInf => Int64 => (IntInf, Int64) };
foster_mp_div_digit_nz = { i : IntInf => b : Int64 =>
  case foster_mp_div_nat_digit_nz (digits i) b
    of (q, remainder) -> (mkIntInf q (isNegative i), remainder)
  end
};

/*
foster_mp_ascii_bytes_in_base_for_abs = { i : IntInf => base : Int32 =>

};
*/

foster_mp_isZero = { i : IntInf =>
  if isNegative i then False else foster_mp_isZero_nat (digits i) end
};

// Precondition:
//      radix is 2 or 10 (eventually should support more radix values).
foster_mp_nat_to_text_radix = { a : Array Int64 => radix : Int32 =>
  if radix ==Int32 2

   then foldRange 0 (used a) "" { d => t =>
          //print_text "radix:d";
          //print_i64b  a[d];
          mkTextConcat (tmp_Text_2_of_Int64 a[d]) t
        };
  else
  if radix ==Int32 10 then
    let ascii-0-1 = 47;
        lookup = newDArray:[Int8] 10 { i:Int32 =>
                       primitive_trunc_i32_i8 (i +Int32 ascii-0-1) };
    in
      rec go = { aa => t =>
                 if foster_mp_isZero_nat aa then t else
                    case foster_mp_div_nat_digit_nz aa 10
                      of (bb, r) ->
                        go bb (mkTextConcat (textOfASCII8
                                        lookup[primitive_trunc_i64_i32 r])
                                     t)
                    end
                 end
               };
      in
        if foster_mp_isZero_nat a then "0" else go a "" end;
      end // rec
    end // let
  else
    "<foster_mp_nat_to_text_radix not yet implemented for this radix>"
  end // if
 end // if
};

// Precondition:
//      radix is 2 or 10 (eventually should support more radix values).
foster_mp_to_text_radix = { i : IntInf => radix : Int32 =>
  let t = foster_mp_nat_to_text_radix (digits i) radix;
  in
      if isNegative i
        then mkTextConcat "-" t
        else t
      end
  end
};

// TODO use base 1`000`000`000`000`000`000 instead of base 10
//      (with zero-padding for intermediate results).


// TODO compiler-rt doesn't yet support
// 128-bit multiplication on 32-bit hosts.
// It seems like it would be significantly
// wasted work, anyhow.
// We should probably go ahead and define
// Word and HalfWord types.

// TODO Int128 intrinsics -- mulq on x86-64 computes 128-bit result.

foster_sqr_i64 = { x : Int64 =>
  if x <=Int64 1839720382
    then (0, x *Int64 x) // x*x won't overflow Int64
    else // might overflow...
      case splitInt64 x
        of (hi32, lo32) ->
         let hi64 = primitive_zext_i32_to_i64 hi32;
             lo64 = primitive_zext_i32_to_i64 lo32;
             lolo = lo64 *Int64 lo64;
             hilo = lo64 *Int64 hi64;
             hihi = hi64 *Int64 hi64;

             // (hilo + hilo) * 2^32
             //     ==  hilo *  2^33
             // will get split between
             // the top and bottom portions
             // of the 128 bit result.

             // [0.32|..64|..96|.128]
             // [  lolo  ] [  hihi  ]
             //        .[ hilo ]
             // The bottom gets the lower
             // 64 - 33 = 31 bits.
             midlo = bitshl-Int64 hilo 33;
             midhi = bitlshr-Int64 hilo 31;
         in
             (hihi +Int64 midhi, lolo +Int64 midlo)
         end
      end
  end
};

// TODO test
foster_mul_i64 = { x : Int64 => y : Int64 =>
  if both (x <=Int64 1839720382) (y <=Int64 1839720382)
    then (0, x *Int64 y) // x*y won't overflow Int64
    else // might overflow...
      case (splitInt64 x, splitInt64 y)
        of ((hi32x, lo32x), (hi32y, lo32y)) ->
         let hi64x = primitive_zext_i32_to_i64 hi32x;
             lo64x = primitive_zext_i32_to_i64 lo32x;
             hi64y = primitive_zext_i32_to_i64 hi32y;
             lo64y = primitive_zext_i32_to_i64 lo32y;
             lolo = lo64x *Int64 lo64y;
             hylx = lo64x *Int64 hi64y;
             hxly = lo64y *Int64 hi64x;
             hihi = hi64x *Int64 hi64y;

             hilo = hylx +Int64 hxly;
             midlo = bitshl-Int64  hilo 32;
             midhi = bitlshr-Int64 hilo 32;
         in
             (hihi +Int64 midhi, lolo +Int64 midlo)
         end
      end
  end
};

min-Int32 = { a : Int32 => b : Int32 =>
  if a <Int32 b then a else b end
};

foster_mp_bitand_nat :: { Array Int64 => Array Int64 => Array Int64 };
foster_mp_bitand_nat = { a => b =>
  let dd = newDArray0 (min-Int32 (used a) (used b))
                     { i : Int32 => bitand-Int64 a[i] b[i] };
  in
      trimLeadingZeros dd;
  end
};

foster_mp_bitand :: { IntInf => IntInf => IntInf };
foster_mp_bitand = { i => j =>
  mkIntInf (foster_mp_bitand_nat (digits i)     (digits j))
           (both             (isNegative i) (isNegative j));
};

// Right-shift by b digits.
//
// Returns None if b is negative.
//
foster_mp_rshd :: { IntInf => Int32 => Maybe IntInf };
foster_mp_rshd = { ii => b =>
  if b <=Int32 0 then None ! else
    let a = digits ii;
        newsize = used a -Int32 b;
     in
      if newsize <=Int32 0 then
        Some (foster_mp_from_Int32 0)
      else
        // old [b0 | b1 | ... | bb | ... | bn ]
        // new [bb | ... | bn ]
        Some (IntInf (newDArray0 newsize { i:Int32 => a[i +Int32 b] })
                     (isNegative ii))
      end
    end
  end
};

// Computes 2 ** k
//
foster_mp_2expt :: { Int32 => IntInf };
foster_mp_2expt = { k =>
  if k <Int32 0 then foster_mp_from_Int32 0 else
    let foster_DIGIT_BIT = 60;
        ndigits          = sdiv-Int32 k foster_DIGIT_BIT;
    in
      // Writing it this way allows us to directly initialize
      // an immutable array, at the (negligible until proven otherwise)
      // cost of a few extra compares.
      IntInf (newDArray0 (ndigits +Int32 1) { i:Int32 =>
                 if i ==Int32 ndigits then
                   bitshl-Int64 1
                     (primitive_zext_i32_to_i64
                        (srem-Int32 k foster_DIGIT_BIT));
                 else 0 end
             })
             False;
    end
  end
};

foster_mp_negate = { ii : IntInf =>
  mkIntInf (digits ii) (not (isNegative ii))
};

// TODO guarantee that functions won't need a closure just for a constant?

foster_mp_rshb_nat :: {    Array Int64 =>         Int32 => Array Int64 };
foster_mp_rshb_nat = { a : Array Int64 => nbits : Int32 =>

    let foster_DIGIT_BIT   = 60;
        foster_DIGIT_BIT64 = 60;
        ndigits = udiv-Int32 nbits foster_DIGIT_BIT;
        newsize = used a -Int32 ndigits;
     in
      if newsize <=Int32 0 then
        mkDigitsOfInt32 0
      else
        let rembits = primitive_zext_i32_to_i64
                         (urem-Int32 nbits foster_DIGIT_BIT);
            irembits = foster_DIGIT_BIT64 -Int64 rembits;
        in
          newDArray0 newsize { i:Int32 =>
             let h0 = a[i +Int32 ndigits];
                 l1 = if i ==Int32 (newsize -Int32 1)
                       then 0
                       else a[i +Int32 ndigits +Int32 1]
                      end;
             in
               // Combine high bits of word i
               // with low bits of word 1 + i.
               bitor-Int64 (bitlshr-Int64 h0 rembits)
                           (bitshl-Int64 l1 irembits);
             end
         };
        end
      end
    end
};

// Right-shift by b bits.
//
foster_mp_rshb :: { IntInf => Int32 => IntInf };
foster_mp_rshb = { ii => nbits =>
  if nbits <=Int32 0
    then ii
    else mkIntInf (foster_mp_rshb_nat (digits ii) nbits) (isNegative ii)
  end
};


foster_mp_getlow_Int32 :: { IntInf => (IntInf, Int32) };
foster_mp_getlow_Int32 = { ii =>
  let k64   = (digits ii)[0];
      k64lo = bitand-Int64 k64 0FFFF`FFFF_16;
  in
    (foster_mp_rshb ii 32, primitive_trunc_i64_i32 k64lo)
  end
};


foster_mp_getlow_Int64 :: { IntInf => (IntInf, Int64) };
foster_mp_getlow_Int64 = { ii =>
  if used (digits ii) ==Int32 1
    then (foster_mp_from_Int32 0 , (digits ii)[0] )
    else
      case foster_mp_getlow_Int32 ii of (jj, low32) ->
        case foster_mp_getlow_Int32 jj of (kk, hi32) ->
          (kk, bitor-Int64
                 (bitshl-Int64 (primitive_zext_i32_to_i64 hi32) 32)
                               (primitive_zext_i32_to_i64 low32))
        end
      end
  end
};

// TODO write & test mp_mod_2d
// TODO test foster_mp_rshd
// TODO write & test mp_div_2, mp_div, mp_sqrt
// TODO ...

/*
foster_mp_int_slow_sqr = { ii : IntInf =>
  let a = digits ii;
      maxsize = (2 *Int32 used a) +Int32 1;
      // assert maxsize > used a (TODO)
      q         = newDArray:[Int64] maxsize { qi => 0 };
      t = foldRange 0 (used a) () { ix => unit =>
            let k = a[ix]; in
              case foster_sqr_i64 of (hi, lo) ->

              end
            end
                r = q[2 *Int32 ix] +Int64
                      (k *Int64 k);

          };

  in

  end
};
*/

// Precondition: k >= 0
//
foster_mp_mul_nat_Int32 = { a : Array Int64 => k : Int32 =>

  let c = allocDArray (used a +Int32 1);
      u = foldRange 0 (used a) 0 { ix => u : Int64 =>
            let k64 = primitive_sext_i64_i32 k;
                foster_MP_MASK = 0FFF`FFFF`FFFF`FFFF_16;
                foster_DIGIT_BIT = 60;
            in
                case foster_mul_i64 (u +Int64 a[ix]) k64 of
                (rhi, rlo) ->
                  (bitand-Int64 rlo foster_MP_MASK) >^ c[ix];

                  // Propagate carry:  [0|0|  c   ][b|   a   ]  ====>
                  //                               [0|  c  |b]
                  bitor-Int64
                    (bitlshr-Int64 rlo foster_DIGIT_BIT)
                    (bitlshr-Int64 rhi (64 -Int64 foster_DIGIT_BIT))
                end
             end
          };
  in
    u >^ c[used a];
    trimLeadingZeros c;
  end

};

// Precondition: k >= 0
//
foster_mp_mul_Int32 = { ii : IntInf => k : Int32 =>

  mkIntInf (foster_mp_mul_nat_Int32 (digits ii) k) (isNegative ii)

};


// Compute (c,d) such that a = c*b + d.
//
// Precondition: b != 0.
//
foster_mp_divmod = { a : IntInf => b : IntInf =>
  case foster_mp_cmp a b
    of $LT -> (foster_mp_from_Int32 0, a) // if a < b then q=0, r = a.
    of _   ->
      // TODO
      (a, b)
  end
};
