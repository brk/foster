import fileinput
import re
import argparse

# Given the path to a Rust source file containing a Pomelo block,
# extracts the tokens and prints C or Rust code giving integer values
# to the discovered names.
#
# As of this writing, the extracted values match those generated by both lemon
# itself as well as pomelo.
#
# But the ordering is essentially arbitrary, if we explicitly map
# from const definition names to the corresponding enum cases.

# Assumption: tokens (and only tokens) are all-caps and at least two letters long.
def extract_tokens(line):
    parts = re.split('\W+', line)
    return [p for p in parts if p.isupper() and len(p) > 1]

def emit_c(tokens):
    for t in tokens:
        print("#define {:<30} {:>3}".format(t, tokens[t]))

def emit_rustconst(tokens):
    for t in tokens:
        print("pub const {} : i32 = {};".format(t, tokens[t]))
    print("")
    print("""
pub fn token_name(t: &super::FrazToken) -> &str {
    raw_token_name(t.tok)
}
pub fn raw_token_name(tok: i32) -> &'static str {
    match tok {
        %s
        -2 => "WHITESPACE",
        -3 => "LINECOMMENT",
        -4 => "BLOCKCOMMENT",
        -5 => "NEWLINE",
        _ => "!token_name_unknown!"
    }
}
"""  % ('\n'.join('        {0} => "{0}",'.format(t) for t in tokens)))

def emit_rustconvert(tokens):
    print("""
fn convert_token(t: super::lex::FrazToken) -> Option<parser::Token> {
    use super::lex;
    match t.tok {
        %s
        _ => None
    }
}
""" % ('\n'.join("        lex::gen::{0} => Some(parser::Token::{0}(t.span)),".format(t) for t in tokens)))

def argparse_files(args):
    return args.input if len(args.input) > 0 else ('-', )

def run(args):
    state = 'start'
    n = 1
    tokens = {}

    for line in fileinput.input(argparse_files(args)):
        line = line.strip()

        if state == 'done':
            continue

        if state == 'start' and line == 'pomelo::pomelo! {':
            state = 'slurp'
            continue

        if state == 'slurp':
            if line == '' or line[0] == '%':
                continue
            if line == '}':
                if args.mode == 'rustconst':
                    emit_rustconst(tokens)
                elif args.mode == 'rustconvert':
                    emit_rustconvert(tokens)
                elif args.mode == 'c':
                    emit_c(tokens)
                else:
                    raise Exception("unknown mode:", args.mode)
                state = 'done'
                break

            ts = extract_tokens(line)
            for t in ts:
                if not t in tokens:
                    tokens[t] = n
                    n += 1

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Extract terminal token values.')
    parser.add_argument('--mode', dest='mode', action='store', default='c',
                        help='output format (c, rustconst, rustconvert)')
    parser.add_argument('input', metavar='FILE', nargs='*',
                        help='output code for a Rust module (otherwise, default to C macros)')

    args = parser.parse_args()
    run(args)
