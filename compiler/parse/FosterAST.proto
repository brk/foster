package foster.fepb;

message SourceLocation {
  required int32 line   = 1;
  required int32 column = 2;
}

message SourceRange {
  optional string         file_path = 1;
  required SourceLocation begin     = 2;
  required SourceLocation end       = 3;
}

message Formatting {
  enum Tag {
    COMMENT = 1;
    NEWLINE = 2;
    NHIDDEN = 3;
  }
  required Tag            tag     = 1;
  optional string         comment = 2;
  required SourceLocation f_loc   = 3;
}

message Type {
  enum Tag {
    TYVAR = 1; // Type variable or constructor
    REF = 2;
    FN  = 3;
    CORO = 4;
    TUPLE = 5;
    CARRAY = 6;
    FORALL_TY = 7;
    TYPE_TYP_APP = 8;
    REFINED_TY = 9;
  }

  optional SourceRange range = 1;
  required Tag         tag   = 2;

  // LLVM_NAMED, TYPE_VARIABLE
  optional string name = 3;
  optional bool   is_placeholder = 4;
  optional Type   ref_underlying_type = 16;
  optional FnType fnty = 17;
  // for tuple, coro, carray, seme prims
  repeated Type type_parts = 18;
  optional uint64 carray_size = 19;

  repeated TypeFormal tyformals = 20; // for FORALL_TY

  optional Expr   refinement = 5;
}

message FnType {
  repeated Type arg_types = 1;
  required Type ret_type  = 2;
  optional string calling_convention = 3;
  optional bool   is_closure = 4;
}

message Formal {
  required string name = 1;
  required Type   type = 2;
}


message Kind {
  enum Tag {
    KIND_TYPE = 1;
    KIND_BOXED = 2;
  }

  required Tag         tag   = 2;
}

message TypeFormal {
  required string name = 1;
  required Kind   kind = 2;
}

message Expr {
  enum Tag {
    VAR       = 14;
    STRING    = 15;
    PB_INT    = 16;
    PB_RAT    = 17;
    BOOL      = 18;
    LET       = 19;
    VAL_ABS   = 21;

    CALL      = 23;
    CALLPRIM  = 33;
    SEQ       = 24;
    TY_APP    = 25;
    TY_CHECK  = 26;
    CASE_EXPR = 30;
    COMPILES  = 31;
    IF        = 32;


    PAT_WILDCARD = 41;
    PAT_VARIABLE = 42;
    PAT_NUM      = 43;
    PAT_BOOL     = 44;
    PAT_CTOR     = 45;
    PAT_TUPLE    = 46;
  }
  repeated Expr        parts = 1;
  required Tag           tag = 2;
  optional Type         type = 3;
  optional SourceRange range = 4;

  optional string string_value = 13; // used for int text, Var, named type decl, val abs
  optional bool   bool_value   = 14;

  optional PBCase     pb_case    = 20;
  optional PBIf       pb_if      = 21;
  optional PBLet      pb_let     = 22;
  optional PBValAbs   pb_val_abs = 23;
  repeated Type ty_app_arg_type = 29; // AnnTyApp
}

message PBValAbs {
  repeated Formal     formals     = 1;
  //optional Type     result_type = 2;
  repeated TypeFormal type_formals = 3;
}

message PBLet {
  repeated TermBinding binding = 1;
  required Expr        body    = 2;
  required bool   is_recursive = 3;
}

message TermBinding {
  required string name = 1;
  required Expr   body = 2;
}

message PBIf {
  required Expr test_expr = 2;
  required Expr then_expr = 3;
  required Expr else_expr = 4;
}

message CaseClause {
  required Expr    pattern   = 1;
  required Expr    body      = 2;
  optional Expr    guard     = 3;
}

message PBCase {
  required Expr       scrutinee = 1;
  repeated CaseClause clauses   = 4;
}

message Decl {
  required string name = 1;
  required Type   type = 2;
}

message Defn {
  required string name = 1;
  required Expr   body = 2;
}

message DataType {
  required TypeFormal     name = 1;
  repeated DataCtor       ctor = 2;
  repeated TypeFormal tyformal = 3;
  optional SourceRange   range = 4;
}

message DataCtor {
  required string   name = 1;
  repeated Type     type = 2;
  optional SourceRange range = 4;
}

message SourceModule {
  required string   self_name = 1;
  required string   hash      = 2;
  repeated string   line      = 4;
  repeated Decl     decl      = 6;
  repeated Defn     defn      = 7;
  repeated DataType data_type = 8;
  repeated Formatting formatting = 9;
}

message WholeProgram {
  repeated SourceModule modules = 1;
}
