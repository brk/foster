package foster.bepb;

message Type {
  enum Tag {
    LLVM_NAMED = 1; // i32, void, etc
    PTR = 2;
    PROC = 3;
    CORO = 4;
    TUPLE = 5;
    CARRAY = 6;
    CLOSURE = 7;
    FORALL_TY = 8;
    TYPE_VARIABLE = 9;
  }

  required Tag         tag   = 2;

  // LLVM_NAMED, TYPE_VARIABLE
  optional string name = 3;
  optional ProcType procty = 17;
  repeated Type type_parts = 18;   // for tuple, coro, carray
  optional uint64 carray_size = 19;
  repeated string tyvar_names = 20; // for FORALL_TY
}

message ProcType {
  repeated Type arg_types = 1;
  required Type ret_type  = 2;
  optional string calling_convention = 3;

  //repeated string annot_key = 3;
  //repeated string annot_val = 4;
}


message Expr {
  enum Tag {
    IL_INT = 16;
    IL_BOOL = 17;
    IL_VAR = 18;
    IL_CLOSURES = 19;
    IL_TUPLE = 20;
    IL_LETVALS = 21;
    IL_CASE = 22;
    IL_CALL = 23;
    IL_SEQ = 24;
    IL_UNTIL = 25;
    IL_SUBSCRIPT = 26;
    IL_CORO_INVOKE = 27;
    IL_CORO_CREATE = 28;
    IL_CORO_YIELD  = 29;
    IL_ALLOC = 30;
    IL_DEREF = 31;
    IL_STORE = 32;
    IL_IF = 33;
    IL_NAMED_TYPE_DECL = 36;
  }
  repeated Expr        parts = 1;
  required Tag           tag = 2;
  optional Type         type = 3;
  repeated Closure  closures = 5;
  repeated string      names = 6;
  optional PBInt      pb_int = 17;
  optional PBIf       pb_if  = 21;

  optional DecisionTree   dt = 22;
  optional bool   bool_value = 23;   // Bool

  optional string name  = 24;  // Var, LETVAL named type decl

  optional bool   is_closure_environment = 25;   // Tuple

  optional CoroPrim coro_prim = 30;
}

message Proc {
  required ProcType proctype = 1;
  repeated string   in_args  = 2;
  required string   name     = 3;
  optional Expr     body     = 4;
  optional string   lines    = 5;
}

message Closure {
  required string varname  = 1;
  required string procid   = 2;
  repeated string varnames = 3;
}

message PBInt {
  // The middle-end is responsible for verifying that the originalText
  // constitutes a syntactically valid literal. For example, FEEDFACE_10
  // is syntactically invalid.
  //
  // The parser is NOT responsible for verifying that the originalText
  // constitutes a syntactically valid literal, because doing so precludes
  // having __COMPILES__ in the language, which requires transmitting
  // possibly-invalid literals to the middle-end.
  //
  // The middle-end is also responsible for checking that the literal is
  // used appropriately (e.g. no passing 64-bit literal to 32-bit func).
  //
  required string clean = 2; // in base 10
  required int32  bits  = 3;
}

message PBIf {
  required Expr test_expr = 2;
  required Expr then_expr = 3;
  required Expr else_expr = 4;
}

message CoroPrim {
  required Type ret_type = 1;
  required Type arg_type = 2;
}

message DecisionTree {
  enum Tag {
    DT_FAIL = 16;
    DT_LEAF = 17;
    DT_SWAP = 18;
    DT_SWITCH = 19;
  }
  required Tag          tag        = 1;
  optional PbSwitchCase switchcase = 4;
  optional Expr         leaf_action = 7;
  repeated string       leaf_idents = 8;
  repeated PbOccurrence leaf_idoccs = 9;
}

message PbSwitchCase {
  repeated PbCtorId     ctors   = 1;
  repeated DecisionTree trees   = 2;
  optional DecisionTree defCase = 3;
  optional PbOccurrence occ     = 4;
}

message PbCtorId {
  required string ctorTypeName = 1;
  required int32  ctorLocalId  = 2;
}

message PbOccurrence {
  repeated int32 occ_offset = 1;
}

message Decl {
  required string name = 1;
  required Type   type = 2;
}

message Module {
  required string modulename = 1;
  repeated Proc   procs      = 2;
  repeated Decl   decls      = 3;
  repeated string modlines   = 4;
}
