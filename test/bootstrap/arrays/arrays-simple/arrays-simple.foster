main = {
  arrays        !;
  arrays8       !;

  // If we lie about our alignment, this will crash.
  let a = "is_ascii_digit c:"; in () end
};

newDArray32 = { n : Int32 => f : { Int32 => Int32 } =>
  a = allocDArray:[Int32] n;
  x = (ref n);

  until x^ ==Int32 0 then
      f x^      >^ a[x^ -Int32  1];
       (x^ -Int32 1) >^ x
  end;
  a
};

arrays = {
  a = newDArray32 2 { n : Int32 => n };
  expect_i32 2;
  print_i32 a[opaquely_i32 1];
};

trunc32to8 = { n : Int32 => trunc_i32_to_i8 n; };

newDArray8 = { n : Int32 => f : { Int32 => Int8 } =>
  a = allocDArray:[Int8] n;
  x = (ref n);
  until x^ ==Int32 0 then
      f x^           >^ a[x^ -Int32  1];
       (x^ -Int32 1) >^ x
  end;
  a
};


print_text = { s : Text =>
  case s
    of $TextFragment a n     -> prim_print_bytes_stderr a n; n
    of $TextConcat   s1 s2 n -> print_text s1; print_text s2; n
   end;
};


arrays8 = {
  k = 26;
  a = newDArray8 k { x : Int32 => trunc32to8 (x +Int32 96) };

  expect_i32 99;
  print_i8 a[opaquely_i32 2];

  (trunc32to8 0) >^ a[3];
  prim_print_bytes_stdout a 6;
  print_abc !;

  expect_i32 k;
  print_i64 (prim_arrayLength a);
};

print_abc = {
  print_text "abc";
};

textLength = { t : Text =>
  case t
    of $TextFragment _ n -> n
    of $TextConcat _ _ n -> n
   end;
};

mkTextConcat = { a : Text => b : Text =>
  TextConcat a b ((textLength a) +Int32 (textLength b))
};

print_concat = {
  print_text (mkTextConcat "abc" "def");
};

