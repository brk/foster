half-open-loops = fn () {
  // loops correspond to half-open ranges: [0, 1)
  expect_i32(0) ; for i in 0 to 1 do { print_i32(i) }
}

terminate-on-overshoot = fn () {
  // termination is computed by <, not !=, so this terminates
  expect_i32(4)
  for i in 0 to 6 by 2 do {
    if 3 < i then { print_i32(i) } else { 0 }
  }
}

incr-is-static = fn () {
  expect_i32(5)
  let incr : ref i32 = new 1 in {
    for i in 0 to 6 by deref(incr) do {
      // this does not affect loop iterations
      set incr = 10
      
      if 4 < i then { print_i32(i) } else { 0 }
    }
  }
}

no-guaranteed-iterations = fn () {
  expect_i32(1234)
  for i in 42 to 42 do {
    print_i32(i)
  }
  ; // TODO this semicolon shouldn't be needed
  print_i32(1234)
}

simple-nesting = fn () {
  expect_i32(100); expect_i32(200)
  expect_i32(100); expect_i32(201)
  expect_i32(101); expect_i32(200)
  expect_i32(101); expect_i32(201)

  for i in 100 to 102 do {
    for j in 200 to 202 do {
      print_i32(i) ; print_i32(j)
    }
  }
}

silly-nesting = fn () {
  expect_i32(200)
  expect_i32(201)
  expect_i32(100)
  
  expect_i32(200)
  expect_i32(201)
  expect_i32(101)
  
  for i in 100 to 102 do {
    for i in 200 to 202 do {
      print_i32(i)
    }
    // shadowing is fine, and does not interfere
    // with outer loop variables
    print_i32(i)
  }
}

fn "main" () {
  half-open-loops()
  terminate-on-overshoot()
  incr-is-static()
  no-guaranteed-iterations()
  simple-nesting()
  silly-nesting()
}
