type case Foo of $Foo Int32 Foo of $FooNil;

main = {
  s1 = foster_subheap_create !;
  s2 = foster_subheap_create !;

  foster_subheap_activate s1;
  x1a = Foo 123 FooNil;

  foster_subheap_activate s2;
  z2 = Foo 234 x1a; // Create subheap-crossing pointer

  foster_subheap_collect s1; // Clear subheap
  x1b = Foo 345 FooNil; // does it overwrite x1a?

  // Interesting point: without these inspection functions,
  // the bindings z2 and x1b are pure && dead, and can therefore
  // be removed by the compiler. If subheaps expose (say)
  // the size of their remembered set, the difference is observable!

  expect_i32 234;
  print_i32 (case z2 of $Foo n _ -> n of $FooNil -> 0 end);

  expect_i32 345;
  print_i32 (case x1b of $Foo n _ -> n of $FooNil -> 0 end);

  expect_i32 123;
  print_i32 (case x1a of $Foo n _ -> n of $FooNil -> 0 end);
};
