hof-while = { t : {Bool} => b : { () } =>
  if t ! then b ! ; hof-while t b
          else () end
};

main = {
  variant-one !;
  variant-two !;
  //stress-hof !;
  //stress-native !;
  //stress-native (ref (opaquely_i32 0));
};

// Our overly-conservative reloading discipline from heap allocation with
// a moving collector forces LLVM to emit silly code like this:
// .LBB11_7:                               # %until_body.L49.i
//                                         #   in Loop: Header=BB11_8 Depth=1
// 	incl	%ecx
// 	movl	%ecx, (%eax)
// .LBB11_8:                               # %until_body.L49.i
//                                         # =>This Inner Loop Header: Depth=1
// 	movl	-8(%ebp), %eax
// 	movl	(%eax), %ecx
// 	cmpl	$100000000, %ecx        # imm = 0x5F5E100
// 	jne	.LBB11_7
//
// which increases the loop's run time from ~85ms to ~250ms
// for 100m iters on my box.
//
// Simply using stack allocation causes LLVM to optimize away the whole loop,
// but manually adding [call void asm sideeffect "", ""()] triggers emission
// of an actual tight loop in the generated assembly:
//.LBB11_9:                               # %until_body.L56.i
//      decl	%ecx
//      jne	.LBB11_9
//
stress-native = {
  let x = (ref 0);
      n = opaquely_i32 10`000`000; in
    until (x^ ==Int32 n) then
       (x^ +Int32 1) >^ x;
    end;
  end;
};

stress-hof = { // 100 mm iters => 1000 ms without inlining
  let x = (ref 0);
      n = opaquely_i32 10`000`000; in
    hof-while { x^ <SInt32 n } {
      (x^ +Int32 1) >^ x
    };
  end
};

variant-one = {
  expect_i32 0;
  expect_i32 1;
  expect_i32 2;
  let v = (ref 0);
      n = opaquely_i32 3;
   in
     hof-while { v^ <SInt32 n } {
       print_i32 v^ ; (v^ +Int32 1) >^ v
     }
  end
};

variant-two = {
  expect_i32 0;
  expect_i32 1;
  expect_i32 2;
  let v = (ref 0);
      n = opaquely_i32 3;
   in
     hof-while { v^ <SInt32 n } {
       print_i32 v^ ; (v^ +Int32 1) >^ v
     }
     // This once triggered a bug where the closure pairs passed to hof-while
     // were being stack-allocated, and TCO resulted in them being clobbered.
  end
};

// TODO check this
// hof-while-unit = { t : {Bool} => b : { () } =>
//   if t ! then b !; hof-while-unit t b
//           else () end
// };
