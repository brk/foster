main = {
  test-assert-bool-lits !;
  test-assert-bool-unrefined True False;
  //test-assert-bool-refined True False;
  test-assert-bool-refined-alt !;
  test-more-bools !;

  test-refined-array-literals !;

  test-assert-ifs !;
};

test-assert-ifs = {
  expect_i1 True;
  print_i1 (__COMPILES__ prim assert-invariants if True then True else False end);

  expect_i1 True;
  print_i1 (__COMPILES__ prim assert-invariants if False then False else True end);

  expect_i1 False;
  print_i1 (__COMPILES__ prim assert-invariants if False then True else False end);
};

test-assert-bool-lits = {
  expect_i1 True;
  print_i1 (__COMPILES__ prim assert-invariants True);

  expect_i1 False;
  print_i1 (__COMPILES__ prim assert-invariants False);
};

test-assert-bool-unrefined = { tru : Bool => fls : Bool =>
  expect_i1 False;
  print_i1 (__COMPILES__ prim assert-invariants tru);

  expect_i1 False;
  print_i1 (__COMPILES__ prim assert-invariants fls);
};

/*
//test-assert-bool-refined = { tru : % t : Bool : prim ==Bool t True
//                          => fls : % f : Bool : prim ==Bool f False
//                          =>
test-assert-bool-refined :: { % t : Bool : prim ==Bool t True
                          =>  % f : Bool : prim ==Bool f False => () };
test-assert-bool-refined = { tru => fls =>
  expect_i1 True;
  print_i1 (__COMPILES__ prim assert-invariants tru);

  expect_i1 False;
  print_i1 (__COMPILES__ prim assert-invariants fls);
};
*/

ret-true :: { % t : Bool : prim ==Bool t True };
ret-true = { True };

ret-false :: { % f : Bool : prim ==Bool f False };
ret-false = { False };

test-assert-bool-refined-alt = {
  tru = ret-true !;
  fls = ret-false !;

  expect_i1 True;
  print_i1 (__COMPILES__ prim assert-invariants tru);

  expect_i1 False;
  print_i1 (__COMPILES__ prim assert-invariants fls);
};

test-refined-array-literals = {
  // Unconstrained type; should it be Int32 or Int64 or ... ?
  expect_i1 False;
  print_i1 (__COMPILES__ prim mach-array-literal 1 2 3);

  expect_i1 True;
  print_i1 (__COMPILES__ prim mach-array-literal :[Int32] 1 2 3);

  expect_i1 True;
  print_i1 (__COMPILES__ prim mach-array-literal :[(% v : Int32 : v <=SInt32 3)] 1 2 3);

  expect_i1 False;
  print_i1 (__COMPILES__ prim mach-array-literal :[(% v : Int32 : v <=SInt32 4)] 1 2 5);

  zzz = 4;
  expect_i1 False;
  print_i1 (__COMPILES__ prim mach-array-literal
                                 :[(% v : Int32 : v <=SInt32 3)]
                                 1 2 zzz);

  yyy = 2;
  expect_i1 True;
  print_i1 (__COMPILES__ prim mach-array-literal
                                 :[(% v : Int32 : v <=SInt32 3)]
                                 1 2 yyy);

  expect_i1 True;
  print_i1 (__COMPILES__ prim mach-array-literal :[(% v : Bool : v)] True True);

  expect_i1 False;
  print_i1 (__COMPILES__ prim mach-array-literal :[(% v : Bool : v)] True False);

  expect_i1 False;
  print_i1 (__COMPILES__ { x : % b : Bool : b => () } False);

  expect_i1 True;
  print_i1 (__COMPILES__ { x : % b : Bool : b => () } True);

};

test-more-bools = {
  expect_i1 True;
  print_i1 (__COMPILES__ foo True);

  expect_i1 False;
  print_i1 (__COMPILES__ foo False);

  expect_i1 True;
  print_i1 (__COMPILES__ bar True);

  expect_i1 False;
  print_i1 (__COMPILES__ bar False);
};

foo :: { % b : Bool : b => () };
foo = { v => () };

bar :: { % b : Bool : prim ==Bool b True => () };
bar = { v => () };





arrayLength :: forall x:Type, { % ra : Array x : True =>
                                % rv : Int64 : rv ==Int64 prim_arrayLength:[x] ra };
arrayLength = { a : Array x => prim_arrayLength a };


readInt64FromArrayInt8-v1 :: { % ra : Array Int8 : 0 <=SInt32 ri =>
                               % ri : Int32 : let woo = arrayLength ra in (zext_i32_to_i64 ri +Int64 7) <SInt64 woo end
                               => Int64 };
readInt64FromArrayInt8-v1 = { a => i =>
  alen = prim_arrayLength a;
  inva = ((zext_i32_to_i64 i +Int64 7) <SInt64 alen);
  prim assert-invariants inva;
  0
};

/*
readInt64FromArrayInt8-v1 :: { % ra : Array Int8 : 0 <=SInt32 ri =>
                          //  % ri : Int32 : (zext_i32_to_i64 ri +Int64 7) <SInt64 prim_arrayLength ra
                            % ri : Int32 : let woo = arrayLength ra in (zext_i32_to_i64 ri +Int64 7) <SInt64 woo end
                          // TODO: this should also work but doesn't:
                          //  % ri : Int32 : (ri +Int32 7) <SInt32 arrayLength32 ra
                            => Int64 };
readInt64FromArrayInt8-v1 = {  a => i =>
  alen = prim_arrayLength a;
  inva = ((zext_i32_to_i64 i +Int64 7) <SInt64 alen);
  prim assert-invariants inva;
  0
};
*/
