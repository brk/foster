snafuinclude Prelude "prelude";
snafuinclude Bitwise "bitwise";

type case BInt of $B Int32;

/*
print_BInt_list = { xs:List BInt =>
  rec go = { xs : List BInt =>
             case xs of $Nil            -> ()
                     of $Cons ($B n) ys -> print_i32 n; print_text ";"; go ys
              end
           };
  in print_text "["; go xs; print_text "]";
  end
};

*/

text_of_BInt = { b:BInt => case b of $B n -> tmp_Text_of_Int32 n end };

main = {
  expect_i32 5;
  print_i32 (prim srem-unsafe-Int32 105 10);

  expect_i32 10;
  print_i32 (prim sdiv-unsafe-Int32 105 10);

  expect_text "123";
  print_text (text_of_BInt (B 123));

  // We expect a single flattened text fragment,
  // not a linear tree of length-one fragments.
  expect_i32 0;
  print_i32 (text_maxdepth (text_of_BInt (B 1234567)));

  expect_text "12345";
  print_text (text_of_BInt (B 12345));

  /*
  let lst = Cons (B 1) (Cons (B 2) (Cons (B 3) Nil));
   in
     //expect_text "[1, 2, 3]";
     //print_text (text_of_list text_of_BInt lst);
  end;
  */

  expect_i32 (observeWordUnsignedWraparound !);
  print_i32 (wordNumBits32 !);

  expect_i32 2;
  print_i32 (bitlength-Word 3);

  expect_i32 3;
  print_i32 (bitlength-Word 4);

  expect_i32 3;
  print_i32 (bitlength-Word 7);

  expect_i32 4;
  print_i32 (bitlength-Word 8);

  test-octet-to-ints !;


  expect_text "8";
  print_text (tmp_Text_of_UInt64 8);

  expect_text "9";
  print_text (tmp_Text_of_UInt64 9);

  expect_text "10";
  print_text (tmp_Text_of_UInt64 10);

  expect_text "11";
  print_text (tmp_Text_of_UInt64 11);

  test-ord !;
  test-int-primitives !;
};

observeWordUnsignedWraparound :: { Int32 };
observeWordUnsignedWraparound = {
  n0 = zext_i32_to_Word 3;
  n1 = bitshl-Word n0 16;
  n2 = bitshl-Word n1 16;
  n3 = bitshl-Word n2 16;
  n4 = bitshl-Word n3 16;

  if n2 ==Word 0
      then 32
      else if n4 ==Word 0
             then 64
             else 128
           end
  end
};

test-octet-to-ints = {
  expect_i32 0;
  print_i32 (octet4ToInt32 0 0 0 0);

  expect_i32 1;
  print_i32 (octet4ToInt32 0 0 0 1);

  expect_i32 256;
  print_i32 (octet4ToInt32 0 0 1 0);

  expect_i32 65536;
  print_i32 (octet4ToInt32 0 1 0 0);
};

test-ord = {
  expect_text "LT";
  print_text (textOfOrd (cmpBoolTrueLTxAlt True False));

  expect_text "GT";
  print_text (textOfOrd (cmpBoolTrueLTxAlt False True));

  expect_text "EQ";
  print_text (textOfOrd (cmpBoolTrueLTxAlt True True));

  expect_text "EQ";
  print_text (textOfOrd (cmpBoolTrueLTxAlt False False));

  expect_text "LT";
  print_text (textOfOrd (cmpBoolTrueLT True False));

  expect_text "GT";
  print_text (textOfOrd (cmpBoolTrueLT False True));

  expect_text "EQ";
  print_text (textOfOrd (cmpBoolTrueLT True True));

  expect_text "EQ";
  print_text (textOfOrd (cmpBoolTrueLT False False));
};

test-int-primitives = {
              2   |> expect_i32;
  f64-to-u32! 2.0 |> print_i32;

           3 |> expect_i32;
  1 +Int32 2 |> print_i32;
};

