snafuinclude PreludePrintExpect "prelude/print-expect";
snafuinclude Bignum "math/bignum";
snafuinclude Text "text";

print_int :: { Int => () };
print_int = { i =>
  sm = prim Int-isSmall i;
  if sm
    then
      w = prim Int-toSmall i;
      print_i64 (zext_Word_to_i64 w);
    else
      ii = prim Int-toBig i;
      printIntInf ii
  end;
};

intFromWord = { w => intFromInt64 (sext_Word_to_i64 w) };

// If w is a small word, Int-ofSmall is more efficient.
Int-ofWord :: { Word => Int };
Int-ofWord = { w =>
  if prim Int-isSmallWord w
    then prim Int-ofSmall w
    else prim Int-ofBig (intFromWord w)
  end
};

noinline_llvm_Int-ofBase256 = { b => n => Int-ofBase256 b n };

Int-ofBase256 :: { Array Int8 => Bool => Int };
Int-ofBase256 = { b => negate =>
  REC loop = { i => idx =>
    next = (intMulInt32 i 256) `intAdd`
           (intFromInt32 (b.[idx] |> zext_i8_to_i32));
    if idx ==Int32 0
      then next
      else loop next (idx -Int32 1)
    end
  };
  
  u = loop (intZero !) (arrayLength32 b -Int32 1);
  b = if negate then intNegate u else u end;
  Int-ofBig b
};

(+Int) :: { Int => Int => Int };
(+Int) = { x => y =>
  case (prim Int-isSmall x, prim Int-isSmall y)
    of (True, True) -> xw = prim Int-toSmall x;
                       yw = prim Int-toSmall y;
                       xw +Word yw |> Int-ofWord

    of (True, False) -> xw = prim Int-toSmall x;
                        yb = prim Int-toBig y;
                        i = intFromWord xw `intAdd` yb;
                        prim Int-ofBig i

    of (False, True) -> yw = prim Int-toSmall y;
                        xb = prim Int-toBig x;
                        i = intFromWord yw `intAdd` xb;
                        prim Int-ofBig i

    of (False, False) -> xb = prim Int-toBig x;
                         yb = prim Int-toBig y;
                         i = intAdd xb yb;
                         prim Int-ofBig i
  end
};

test-ints = {
  expect = { x : Int32 => i : Int =>
    expect_i32 x;
    print_int i;
  };

/*
  // Literals that fit in 63 bits:
  expect_text "102030405060708090";
  print_int 102030405060708090;

  expect_text "192030405060708091";
  print_int (  102030405060708090 +Int
                90000000000000001);

  expect_text "102030405060718091";
  print_int (  102030405060708090 +Int
                            10001);

  expect_text "102030405060718091";
  print_int (               10001 +Int
               102030405060708090);

  expect_text "120034";
  print_int   (120000 +Int 34);
*/

  // Larger literals:

  expect_text "22213632912598862894889094373145828843847681";
  print_int  0xFF0000000000000000000000000000000001;

  expect_text "22213632912598862894889094373145828843847681";
  print_int (Int-ofBase256 b"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF" False);

};

main = {
  expect_i32 567;
  print_i64  567;

  test-ints !;
};
