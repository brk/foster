main = {
  expect_i1 False;
  print_i1 (__COMPILES__ { x => (x as (forall (a:Type) { a => a }))} );
  // The above line gets type checked roughly as follows:
  // * x gets a meta type variable T
  // * x is checked against (forall a. a -> a)
  // *     The polytype is skolemized to (b -> b)
  // * T unifies with (b -> b)
  // * Rule SKOL fails because the skolem constant b is now free in T.

  expect_i1 False;
  print_i1 (__COMPILES__ ({ z : ?? ZEE => () } as forall (f:Type) { f => () }) );
  // The above is an equivalent local encoding to having, at global scope,
  //        zee :: forall (f:Type) { f => () };
  //        zee = { z => () };
  //
  // The ?? ZEE metavariable simply makes it clearer what's happening.
  ()
};

// This works
boo = { forall f:Type, z : f =>
  g = { x => (x as { f => f })};
  ()
};
