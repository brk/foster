test-cmp-swap = fn(a:ref i32) {
  llvm.atomic.cmp.swap.i32.p0i32(a, 0, 1)
  expect_i32(3) ; print_i32(deref(a))
  
  llvm.atomic.cmp.swap.i32.p0i32(a, 3, 4)
  expect_i32(4) ; print_i32(deref(a))
}

test-swap = fn(a:ref i32) {
  expect_i32(13) ; print_i32(llvm.atomic.swap.i32.p0i32(a, 14))
  expect_i32(14) ; print_i32(deref(a))
}

test-load-add = fn(a:ref i32) {
  expect_i32(23) ; print_i32(llvm.atomic.load.add.i32.p0i32(a, 1))
  expect_i32(24) ; print_i32(deref(a))
}

test-load-sub = fn(a:ref i32) {
  expect_i32(123) ; print_i32(llvm.atomic.load.sub.i32.p0i32(a, 1))
  expect_i32(122) ; print_i32(deref(a))
}

// atomic.load.and.*  &  atomic.load.or.*
// conflict with grammar keywords for now...

test-load-xor = fn(a:ref i32) {
  expect_i32(10001_2) ; print_i32(llvm.atomic.load.xor.i32.p0i32(a, 00111_2))
  expect_i32(10110_2) ; print_i32(deref(a))
}

// For LLVM 2.6, load.nand actually computes A & ~B, not ~(A & B),
// in order to maintain compatibility with GCC 4.2
//test-load-nand = fn(a:ref i32) {
//  expect_i32(110101_2) ; print_i32(llvm.atomic.load.nand.i32.p0i32(a, 111011_2))
//  expect_i32(001111_2) ; print_i32(deref(a))
//  // actual: 001010_2
//}

test-load-max = fn(a:ref i32) {
  expect_i32(1234) ; print_i32(llvm.atomic.load.max.i32.p0i32(a, 1233))
  expect_i32(1234) ; print_i32(deref(a))
  
  set a = 1123
  expect_i32(1123) ; print_i32(llvm.atomic.load.max.i32.p0i32(a, 1124))
  expect_i32(1124) ; print_i32(deref(a))
}

fn "main" () {
  test-cmp-swap(new 3)
  test-swap(new 13)
  test-load-add(new 23)
  test-load-sub(new 123)
  
  test-load-xor(new  10001_2)
  //test-load-nand(new 110101_2)
  
  test-load-max(new 1234)
}
