// Based on the Haskell implementation (#4):
//   https://benchmarksgame.alioth.debian.org/u32/program.php?test=binarytrees&lang=ghc&id=4
// for the Computer Language Benchmarks Game

snafuinclude Text "text";
snafuinclude Prelude "prelude";

type case Tree
  of $TNil
  of $Node Int32 Tree Tree
  ;

minN = { 4 };

io = { s => n => t =>
  print_text_bare s;
  print_text_bare " of depth ";
  print_i64_bare (zext_i32_to_i64 n);
  print_text_bare "\t check: ";
  print_i32 t;
};

iot = { m => s => n => t =>
  print_i64_bare (zext_i32_to_i64 m);
  print_text_bare s;
  print_text_bare " of depth ";
  print_i64_bare (zext_i32_to_i64 n);
  print_text_bare "\t check: ";
  print_i32 t;
};

bit :: { Int32 => Int32 };
bit = { n => bitshl-Int32 1 n };

main = {
    n = tmp_Int32_of_base_10_Text (get_cmdline_arg_n 1);
    maxN = if n >=SInt32 6 then n else 6 end;
    stretchN = maxN +Int32 1;

    subheapL = foster_subheap_create !;
    subheap = foster_subheap_create !;

    prev = foster_subheap_activate subheap;

    c = checkX (make 0 stretchN);
    io "stretch tree" stretchN c;

    foster_subheap_collect subheap;
    //foster_subheap_shrink subheap;

    ignored = foster_subheap_activate subheapL;

    long    = make 0 maxN;

    ignored = foster_subheap_activate subheap;

    REC depth = { mn => mx =>
      REC sumT = { d => i => t =>
        if i ==Int32 0
          then t
          else
            a = checkX (make i d);
            b = checkX (make (0 -Int32 i) d);
            ans = a +Int32 b +Int32 t;
            sumT d (i -Int32 1) ans
        end
      };

      if mn <=SInt32 mx then
        n = bit ((mx -Int32 mn) +Int32 (minN !));
        i = sumT mn n 0;
        print_text "collecting subheap...";
            foster_subheap_collect subheap;
        m = 2 *Int32 n;
        iot m "\t trees" mn i;
        depth (mn +Int32 2) mx
      end
    };
    depth (minN !) maxN;

    io "long lived tree" maxN (checkX long);
};

checkN = { t : Tree => 0 };

checkX = { t : Tree =>
  case t
    of $TNil -> 0
    of $Node i l r ->
      case l of $TNil -> i
             of _ -> ((checkX l) +Int32 i) -Int32 (checkX r);
      end
    end
};
checkA = { t : Tree =>
  REC gocheck = { b => z => t =>
    case t
      of $TNil -> z
      of $Node i l r -> nl = gocheck b (if b then z +Int32 i else z -Int32 i end) l;
                        gocheck (not b) nl r
    end
  };
  gocheck True 0 t
};

make = { i => d =>
  if d ==Int32 0
    then Node i TNil TNil
    else i2 = i *Int32 2;
         d2 = d -Int32 1;
         Node i (make (i2 -Int32 1) d2) (make i2 d2)
  end
};
