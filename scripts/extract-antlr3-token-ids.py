#!/usr/bin/env python3

import sys
import fileinput
import re
import random
import datetime

# Simple script to grub through ANTLR3C's generated output
# and extract the mapping between token names and numbers.

def collectTokenIdPairs():
  pairs = []
  for line in fileinput.input():
    m = re.match(r"#define ([^ ]+) +(\d+)", line)
    if m:
      pairs.append( (m.group(1), m.group(2)) )
  return pairs

def formatHaskellTokenDef(pair):
  prefix = ""
  if doWeExpectTokenToBeUnused(pair[0]):
    prefix = "_"
  tok = "%stok_%s" % (prefix, pair[0])
  return '\n'.join(["%s :: Int" % tok,
                    "%s = %s" % (tok, pair[1])])

def printHaskellTokenDefs(pairs):
  for p in pairs:
    print(formatHaskellTokenDef(p))

  print()
  print("tokNameOf id =")
  print("  case id of")
  for p in pairs:
    nm, num = p
    print('    %s -> "%s"' % (num, nm))
  print('    _ -> "<unknown token" ++ show id ++ ">"')

unusedTokenList = set("""
TICK_STR_CONTENTS
UNDER_IDENT
SYMBOL_CONTINUE_NDIG
WORD_CHAR
DO
TYPE
TICK_STR
SMALL_IDENT
INT_RAT_BASE
IDENT_START_SMALL
NL
EQ
DQUO_STR
T__139
T__138
T__137
T__136
SYMBOL_MULTI_START
SYMBOL
LINE_COMMENT
PARSE_DECL
ELSE
SYMBOL_SINGLE_START
T__141
T__142
T__140
IDENT_SYMBOL
TYPE_TYP_ABS
T__143
T__144
T__126
T__125
T__128
UNICODE_INNER
IDENT_CONTINUE
T__127
WS
T__129
TDQU_STR
SYMBOL_CONTINUE
END
T__130
T__131
T__132
T__133
T__134
BACKSLASH
T__135
WHERE
T__118
T__119
T__116
T__117
T__114
T__115
T__124
T__123
T__122
T__121
UPPER_IDENT
T__120
AND
TYPE_CTOR
AT
AS
ESC_SEQ
THEN
IN
SEQ
IS
IT
DIGIT
DQUO
STR_TAG
KIND_TYOP
IDENT_START_UPPER
TYP_ABS
TICK
TO
TRTK_STR
SCI_NOTATION
HEX_DIGIT
ASSIGN_TO
MINUS
NUM
HEX_CLUMP
FORMALS
DQUO_STR_CONTENTS
LET
NESTING_COMMENT
""".split())

def doWeExpectTokenToBeUnused(tok):
  return tok in unusedTokenList

if __name__ == "__main__":
  print("module Foster.Tokens where")
  print()
  print("-- Autogenerated on:", datetime.datetime.now())
  print()
  printHaskellTokenDefs(collectTokenIdPairs())

