snafuinclude Bytes "bytes";
snafuinclude RAB "resizable-array-builder";
snafuinclude Prelude "prelude";
snafuinclude Bitwise "math/bitwise";

type case DeflateBlockType
       of $DeflateNonCompressedBlock // 0
       of $DeflateFixedBlock         // 1
       of $DeflateDynamicBlock       // 2
       ;


mkCRCTable = {
  prim mach-array-literal 00_16 077073096_16 0ee0e612c_16 0990951ba_16 076dc419_16 0706af48f_16 0e963a535_16 09e6495a3_16 0edb8832_16 079dcb8a4_16 0e0d5e91e_16 097d2d988_16 09b64c2b_16 07eb17cbd_16 0e7b82d07_16 090bf1d91_16 01db71064_16 06ab020f2_16 0f3b97148_16 084be41de_16 01adad47d_16 06ddde4eb_16 0f4d4b551_16 083d385c7_16 0136c9856_16 0646ba8c0_16 0fd62f97a_16 08a65c9ec_16 014015c4f_16 063066cd9_16 0fa0f3d63_16 08d080df5_16 03b6e20c8_16 04c69105e_16 0d56041e4_16 0a2677172_16 03c03e4d1_16 04b04d447_16 0d20d85fd_16 0a50ab56b_16 035b5a8fa_16 042b2986c_16 0dbbbc9d6_16 0acbcf940_16 032d86ce3_16 045df5c75_16 0dcd60dcf_16 0abd13d59_16 026d930ac_16 051de003a_16 0c8d75180_16 0bfd06116_16 021b4f4b5_16 056b3c423_16 0cfba9599_16 0b8bda50f_16 02802b89e_16 05f058808_16 0c60cd9b2_16 0b10be924_16 02f6f7c87_16 058684c11_16 0c1611dab_16 0b6662d3d_16 076dc4190_16 01db7106_16 098d220bc_16 0efd5102a_16 071b18589_16 06b6b51f_16 09fbfe4a5_16 0e8b8d433_16 07807c9a2_16 0f00f934_16 09609a88e_16 0e10e9818_16 07f6a0dbb_16 086d3d2d_16 091646c97_16 0e6635c01_16 06b6b51f4_16 01c6c6162_16 0856530d8_16 0f262004e_16 06c0695ed_16 01b01a57b_16 08208f4c1_16 0f50fc457_16 065b0d9c6_16 012b7e950_16 08bbeb8ea_16 0fcb9887c_16 062dd1ddf_16 015da2d49_16 08cd37cf3_16 0fbd44c65_16 04db26158_16 03ab551ce_16 0a3bc0074_16 0d4bb30e2_16 04adfa541_16 03dd895d7_16 0a4d1c46d_16 0d3d6f4fb_16 04369e96a_16 0346ed9fc_16 0ad678846_16 0da60b8d0_16 044042d73_16 033031de5_16 0aa0a4c5f_16 0dd0d7cc9_16 05005713c_16 0270241aa_16 0be0b1010_16 0c90c2086_16 05768b525_16 0206f85b3_16 0b966d409_16 0ce61e49f_16 05edef90e_16 029d9c998_16 0b0d09822_16 0c7d7a8b4_16 059b33d17_16 02eb40d81_16 0b7bd5c3b_16 0c0ba6cad_16 0edb88320_16 09abfb3b6_16 03b6e20c_16 074b1d29a_16 0ead54739_16 09dd277af_16 04db2615_16 073dc1683_16 0e3630b12_16 094643b84_16 0d6d6a3e_16 07a6a5aa8_16 0e40ecf0b_16 09309ff9d_16 0a00ae27_16 07d079eb1_16 0f00f9344_16 08708a3d2_16 01e01f268_16 06906c2fe_16 0f762575d_16 0806567cb_16 0196c3671_16 06e6b06e7_16 0fed41b76_16 089d32be0_16 010da7a5a_16 067dd4acc_16 0f9b9df6f_16 08ebeeff9_16 017b7be43_16 060b08ed5_16 0d6d6a3e8_16 0a1d1937e_16 038d8c2c4_16 04fdff252_16 0d1bb67f1_16 0a6bc5767_16 03fb506dd_16 048b2364b_16 0d80d2bda_16 0af0a1b4c_16 036034af6_16 041047a60_16 0df60efc3_16 0a867df55_16 0316e8eef_16 04669be79_16 0cb61b38c_16 0bc66831a_16 0256fd2a0_16 05268e236_16 0cc0c7795_16 0bb0b4703_16 0220216b9_16 05505262f_16 0c5ba3bbe_16 0b2bd0b28_16 02bb45a92_16 05cb36a04_16 0c2d7ffa7_16 0b5d0cf31_16 02cd99e8b_16 05bdeae1d_16 09b64c2b0_16 0ec63f226_16 0756aa39c_16 026d930a_16 09c0906a9_16 0eb0e363f_16 072076785_16 05005713_16 095bf4a82_16 0e2b87a14_16 07bb12bae_16 0cb61b38_16 092d28e9b_16 0e5d5be0d_16 07cdcefb7_16 0bdbdf21_16 086d3d2d4_16 0f1d4e242_16 068ddb3f8_16 01fda836e_16 081be16cd_16 0f6b9265b_16 06fb077e1_16 018b74777_16 088085ae6_16 0ff0f6a70_16 066063bca_16 011010b5c_16 08f659eff_16 0f862ae69_16 0616bffd3_16 0166ccf45_16 0a00ae278_16 0d70dd2ee_16 04e048354_16 03903b3c2_16 0a7672661_16 0d06016f7_16 04969474d_16 03e6e77db_16 0aed16a4a_16 0d9d65adc_16 040df0b66_16 037d83bf0_16 0a9bcae53_16 0debb9ec5_16 047b2cf7f_16 030b5ffe9_16 0bdbdf21c_16 0cabac28a_16 053b39330_16 024b4a3a6_16 0bad03605_16 0cdd70693_16 054de5729_16 023d967bf_16 0b3667a2e_16 0c4614ab8_16 05d681b02_16 02a6f2b94_16 0b40bbe37_16 0c30c8ea1_16 05a05df1b_16 02d02ef8d_16;
};

crcUpdate = { crc : Int32 => inp =>
  x = { v => v `bitxor-Int32` 0xFFFF`FFFF };
  t = mkCRCTable !;

  (foldRange 0 (bytesLength32 inp) (x crc) { n => c =>
    v = bytesGet! (zext_i32_to_i64 n) inp |> zext_i8_to_i32;
    idx = (c `bitxor-Int32` v) `bitand-Int32` 255;
    t[idx] `bitxor-Int32` (c `bitlshr-Int32` 8)
  }) |> x
};

crcBytes = { inp : Bytes => crcUpdate 0 inp };

isFixed = { blocktype =>
  case blocktype
    of $DeflateFixedBlock -> True
    of _ -> False
  end
};

isDynamic = { blocktype =>
  case blocktype
    of $DeflateDynamicBlock -> True
    of _ -> False
  end
};

either3 = { a => b => c => either a (either b c) };

addBit = { outp => bit => bp : Ref Word =>
  if bp^ ==Word 0
    then rabAppendWord8 outp 0;
  end;
  rabWriteBit outp (rabSize outp) (bp^ ) bit;
  ((bp^ +Word 1) `bitand-Word` 7) >^ bp;
};

addBits = { outp => val : Int32 => len => bp : Ref Word =>
  enumRange32 0 len { i => addBit outp (testBit32 val i) bp };
};

addHuffmanBits = { outp => val : Int32 => len => bp : Ref Word =>
  enumRange32 0 len { i => addBit outp (testBit32 val (len -Int32 i -Int32 1)) bp };
};

// Returns (Maybe Int32) correponding to the last index from the back
// for which the given predicate holds.
findLastSatisfying = { arr => pred =>
  foldRangeDown (arrayLength32 arr) 0 None { i => acc =>
    case (pred arr[i], acc)
      of (True, $None) -> Some i
      of _ -> acc
    end
  }
};

// Returns (Maybe Int32) correponding to the last index from the back
// for which the given predicate holds.
findLastSatisfyingFromTo = { start => dest => pred =>
  foldRangeDown start dest None { i => acc =>
    case (pred i, acc)
      of (True, $None) -> Some i
      of _ -> acc
    end
  }
};

findLastSatisfyingFromToOrZero = { start => desc => pred =>
  case findLastSatisfyingFromTo start desc pred
    of $Some i -> i
    of $None   -> 0
  end
};

absDiff64 = { x => y =>
  if x >SInt64 y then x -Int64 y
                 else y -Int64 x end
};

absDiff32 = { x => y =>
  if x >SInt32 y then x -Int32 y
                 else y -Int32 x end
};

optimizeHuffmanForRLE = { counts : Array Int64 =>
  mbFirstNonZero = findLastSatisfying counts { v => v !=Int64 0 };
  case mbFirstNonZero
    of $None -> ()
    of $Some firstNonZero ->
      length = firstNonZero +Int32 1;

      goodForRLE = allocDArray length;
      arrayZero32 goodForRLE;
      // TODO range fold with two state variables shouldn't allocate...
      _res = foldRange 0 (min-SInt32 length (arrayLength32 counts))
                         (trunc_i64_to_i32 counts[0], 0) { i => symstride =>
        let (symbol, stride) = symstride;
        if (i ==Int32 length) `either` (trunc_i64_to_i32 counts[i] !=Int32 symbol)
          then // hit the end, or broke our streak
            if either ((symbol ==Int32 0) `both` (stride >=SInt32 5))
                      ((symbol !=Int32 0) `both` (stride >=SInt32 7))
              then
                enumRange32 0 stride { k => 1 >^ goodForRLE[i -Int32 k -Int32 1] };
            end;
            newsym = if i ==Int32 length then symbol else counts[i] |> trunc_i64_to_i32 end;
            (newsym, 1)
          else (symbol, stride +Int32 1)
        end
      };

      // step 3
      foldRange 0 (length +Int32 1) (0, counts[0], 0) { i => sls : (Int32, Int64, Int32) =>
        let (stride, limit, sum) = sls;

        let (newstride, newlimit, newsum0) =
          if { either (i ==Int32 length)
                      (goodForRLE[i] !=Int32 0) } `oror`
                      { absDiff64 counts[i] limit >=SInt64 4 }
            then
                 if either (stride >=SInt32 4) (both (stride >=SInt32 3) (sum ==Int32 0))
                   then
                     count0 = (sum +Int32 (stride `sdiv-Int32` 2)) `sdiv-Int32` stride;
                     count = case (sum ==Int32 0, count0 <SInt32 1)
                               of (True, _) -> 0
                               of (_, True) -> 1
                               of _ -> count0
                             end |> zext_i32_to_i64;
                     enumRange32 0 stride { k =>
                       count >^ counts[i -Int32 k -Int32 1];
                     };
                 end;

                 newlimit = case (i <SInt32 (length -Int32 3), i <SInt32 length)
                              of (True, _) -> (counts[i] +Int64
                                               counts[i +Int32 1] +Int64
                                               counts[i +Int32 2] +Int64
                                               counts[i +Int32 3] +Int64 2)
                                                            `sdiv-Int64` 4;
                              of (_, True) -> counts[i]
                              of _         -> 0
                            end;

                 (0, newlimit, 0)
            else (stride, limit, sum)
          end;

        newsum = if i ==Int32 length then newsum0 else newsum0 +Int32 cast_i64_to_i32 counts[i] end;
        (newstride +Int32 1, newlimit, newsum)
      };

      // goodForRLE is now garbage
      ()
  end
};

/*
Adds all lit/len and dist codes from the lists as huffman symbols. Does not add
end code 256. expected_data_size is the uncompressed block size, used for
assert, but you can set it to 0 to not do the assertion.
*/
addLZ77Data = { outp => bp =>
                  litlens : Array Int64 =>
                  dists   : Array Int64 => lstart => lend =>
                  ll_symbols : Array Int64 => ll_lengths : Array Int64 =>
                  d_symbols  : Array Int64 => d_lengths  : Array Int64 =>
  testlength = prim ref 0;

  enumRange32 lstart lend { i =>
    dist = dists[i];
    litlen64 = litlens[i];
    litlen32 = litlen64 |> trunc_i64_to_i32;
    if dist ==Int64 0 then
      //assert(litlen < 256);
      //assert(ll_lengths[litlen] > 0);
      addHuffmanBits outp (ll_symbols[litlen32] |> trunc_i64_to_i32)
                          (ll_lengths[litlen32] |> trunc_i64_to_i32) bp;
      (testlength^ +Int64 1) >^ testlength;
    else
      lls = zopfliGetLengthSymbol litlen64;
      ds = zopfliGetDistSymbol dist;
      //assert(litlen >= 3 && litlen <= 288);
      //assert(ll_lengths[lls] > 0);
      //assert(d_lengths[ds] > 0);
      addHuffmanBits outp (ll_symbols[lls] |> trunc_i64_to_i32)
                          (ll_lengths[lls] |> trunc_i64_to_i32) bp;
      addBits outp (zopfliGetLengthExtraBitsValue litlen64)
                   (zopfliGetLengthExtraBits litlen64) bp;
      addHuffmanBits outp (d_symbols[ds] |> trunc_i64_to_i32)
                          (d_lengths[ds] |> trunc_i64_to_i32) bp;
      addBits outp (zopfliGetDistExtraBitsValue dist)
                   (zopfliGetDistExtraBits dist) bp;
      (testlength^ +Int64 litlen64) >^ testlength;
    end
  };
  //assert(expected_data_size == 0 || testlength == expected_data_size);
};

patchDistanceCodesForBuggyDecoders = { d_lengths =>
  num_dist_codes = foldRange 0 30 0 { i => ndc =>
                     if d_lengths[i] !=Int64 0
                       then ndc +Int32 1
                       else ndc
                     end
                   };
  case num_dist_codes
    of 0 -> 1 >^ d_lengths[0]; 1 >^ d_lengths[1];
    of 1 -> idx = if d_lengths[0] !=Int64 0 then 1 else 0 end; 1 >^ d_lengths[idx];
    of _ -> ()
  end;
};

zopfliLZ77Counts = { litlens : Array Int64 =>
                     dists   : Array Int64 =>
                     lstart => lend =>
                     ll_counts : Array Int64 =>
                     d_counts  : Array Int64 =>
  enumRange32 0 288 { i => 0 >^ ll_counts[i] };
  enumRange32 0 32  { i => 0 >^ d_counts[i] };
  enumRange32 lstart lend { i =>
    if dists[i] ==Int64 0 then
      (ll_counts[litlens[i]] +Int64 1) >^ ll_counts[litlens[i]];
    else
      sl = zopfliGetLengthSymbol litlens[i];
      sd = zopfliGetDistSymbol   dists[i];
      (ll_counts[sl] +Int64 1) >^ ll_counts[sl];
      (d_counts[sd] +Int64 1) >^ d_counts[sd];
    end
  };

  1 >^ ll_counts[256];  /* End symbol. */
};


/*
Calculates the optimal path of lz77 lengths to use, from the calculated
length_array. The length_array must contain the optimal length to reach that
byte. The path will be filled with the lengths to use, so its data size will be
the amount of lz77 symbols.
*/
traceBackwards = { size : Int64 => lengths => path =>
  if size !=Int64 0 then
      REC go = { index : Int32 =>
        // HERE --  https://github.com/google/zopfli/blob/master/src/zopfli/squeeze.c#L476
        //          do we want SERA instead of RAB? need append and index, RAB needs ugly sizeof factors
        //ZOPFLI_APPEND_DATA(length_array[index], path, pathsize);
        rabAppendWord32 path lengths[index];
        //assert(length_array[index] <= index);
        //assert(length_array[index] <= ZOPFLI_MAX_MATCH);
        //assert(length_array[index] != 0);
        newindex = index -Int32 lengths[index];
        if newindex !=Int32 0 then go newindex end;
      };
      go (trunc_i64_to_i32 size);

      /* Mirror result. */
      enumRange32 0 (rabSize32 path `sdiv-Int32` 2) { index =>
        temp = rabReadWord32 path index;
        oidx = (rabSize32 path -Int32 index -Int32 1) *Int32 4;
        rabWriteWord32 path (rabReadWord32 path oidx) (index *Int32 4);
        rabWriteWord32 path  temp               oidx;
      };
  end;
};

rabSize32 =  { rab => rabSize rab |> cast_Word_to_i32 };
rabReadWord32 = { rab => offset => 0 }; // TODO

followPath = { state => inp => path => store =>
  ()
  /*
  size_t i, j, pos = 0;
  size_t windowstart = instart > ZOPFLI_WINDOW_SIZE
      ? instart - ZOPFLI_WINDOW_SIZE : 0;

  size_t total_length_test = 0;

  ZopfliHash hash;
  ZopfliHash* h = &hash;

  if (instart == inend) return;

  ZopfliInitHash(ZOPFLI_WINDOW_SIZE, h);
  ZopfliWarmupHash(in, windowstart, inend, h);
  for (i = windowstart; i < instart; i++) {
    ZopfliUpdateHash(in, i, inend, h);
  }

  pos = instart;
  for (i = 0; i < pathsize; i++) {
    unsigned short length = path[i];
    unsigned short dummy_length;
    unsigned short dist;
    assert(pos < inend);

    ZopfliUpdateHash(in, pos, inend, h);

    // Add to output.
    if (length >= ZOPFLI_MIN_MATCH) {
      // Get the distance by recalculating longest match. The found length
      // should match the length from the path.
      ZopfliFindLongestMatch(s, h, in, pos, inend, length, 0,
                             &dist, &dummy_length);
      assert(!(dummy_length != length && length > 2 && dummy_length > 2));
      ZopfliVerifyLenDist(in, inend, pos, dist, length);
      ZopfliStoreLitLenDist(length, dist, store);
      total_length_test += length;
    } else {
      length = 1;
      ZopfliStoreLitLenDist(in[pos], 0, store);
      total_length_test++;
    }


    assert(pos + length <= inend);
    for (j = 1; j < length; j++) {
      ZopfliUpdateHash(in, pos + j, inend, h);
    }

    pos += length;
  }

  ZopfliCleanHash(h);
  */
};

/*
Does a single run for ZopfliLZ77Optimal. For good compression, repeated runs
with updated statistics should be performed.
s: the block state
in: the input data array
instart: where to start
inend: where to stop (not inclusive)
path: pointer to dynamically allocated memory to store the path
pathsize: pointer to the size of the dynamic path array
length_array: array if size (inend - instart) used to store lengths
costmodel: function to use as the cost model for this squeeze run
costcontext: abstract context for the costmodel function
store: place to output the LZ77 data
returns the cost that was, according to the costmodel, needed to get to the end.
    This is not the actual cost.
*/
lz77OptimalRun = { state
                => inp
                => pathr
                => lengths
                => costmodel
                => store
                =>
  cost = getBestLengths state inp costmodel lengths;
  path = newResizableArrayBuilder !;
  traceBackwards (bytesLength inp) lengths path;
  followPath state inp path store;
  cost
};

getBestLengths = { state => inp => costmodel => lengths =>
  // TODO
  0.0
};

zopfliLengthLimitedCodeLengths = { frequencies : Array Int64 => n => maxbits => bitlengths =>

  // NodePool pool;
  i = (prim ref 0);
  numsymbols = (prim ref 0); // Amount of symbols with frequency > 0.
  numBoundaryPMRuns = (prim ref 0);

  // One leaf per symbol. Only numsymbols leaves will be used.
  leaves = allocDArray:[Node] n;

    /* Array of lists of chains. Each list requires only two lookahead chains at
  a time, so each list is a array of two Node*'s. */
  //Node* (*lists)[2];

  /* Initialize all bitlengths at 0. */
  enumRange32 0 n { i => 0 >^ bitlengths[i]; };

  /* Count used symbols and place them in the leaves. */
  enumRange 0 n { i =>
    if frequencies[i] !=Int64 0 then
      leafWeightSet leaves[numsymbols] frequencies[i];
      leafCountSet  leaves[numsymbols] i;  /* Index of symbol this leaf represents. */
      (numsymbols +Int32 1) >^ numsymbols;
    end
  };

  /* Check special cases and error conditions. */
  case ()
    of _ if (1 `bitshl-Int32` maxbits) <SInt32 numsymbols -> 1
    of _ if numsymbols^ ==Int32 0 -> 0 // No symbols at all. OK.
    of _ if numsymbols^ ==Int32 1 ->
        1 >^ bitlengths[leafCount leaves[0]];
        0 // Only one symbol, give it bitlength 1, not 0. OK.
    of _ ->
/*

  /* Sort the leaves from lightest to heaviest. */
  qsort(leaves, numsymbols, sizeof(Node), LeafComparator);

  /* Initialize node memory pool. */
  pool.size = 2 * maxbits * (maxbits + 1);
  pool.nodes = (Node*)malloc(pool.size * sizeof(*pool.nodes));
  pool.next = pool.nodes;
  for (i = 0; i < pool.size; i++) {
    pool.nodes[i].inuse = 0;
  }

  lists = (Node* (*)[2])malloc(maxbits * sizeof(*lists));
  InitLists(&pool, leaves, maxbits, lists);

  /* In the last list, 2 * numsymbols - 2 active chains need to be created. Two
  are already created in the initialization. Each BoundaryPM run creates one. */
  numBoundaryPMRuns = 2 * numsymbols - 4;
  for (i = 0; i < numBoundaryPMRuns; i++) {
    char final = i == numBoundaryPMRuns - 1;
    BoundaryPM(lists, maxbits, leaves, numsymbols, &pool, maxbits - 1, final);
  }

  ExtractBitLengths(lists[maxbits - 1][1], leaves, bitlengths);

  free(lists);
  free(leaves);
  free(pool.nodes);
  return 0;  /* OK. */
*/
    0
  end;
};

zopfliCalculateBitLengths = { counts : Array Int64 => maxbits => lengths : Array Int64 =>
  error = zopfliLengthLimitedCodeLengths counts (arrayLength32 counts) maxbits lengths;
  if error !=Int32 0
    then prim kill-entire-process "zopfliCalculateBitLengths failed";
    else ()
  end
};

getDynamicLengths = { litlens => dists => lstart => lend => ll_lengths : Array Int64 => d_lengths =>
  ll_counts = allocDArray:[Int64] 288;
  d_counts  = allocDArray:[Int64]  32;

  zopfliLZ77Counts litlens dists lstart lend ll_counts d_counts;
  optimizeHuffmanForRLE ll_counts;
  optimizeHuffmanForRLE  d_counts;
  zopfliCalculateBitLengths ll_counts 15 ll_lengths;
  zopfliCalculateBitLengths  d_counts 15  d_lengths;
  patchDistanceCodesForBuggyDecoders d_lengths;
  ()
};


zopfliLengthsToSymbols = { lengths : Array Int64 => n => maxbits => symbols : Array Int64 =>
  bl_count  = allocDArray (maxbits +Int32 1);
  next_code = allocDArray (maxbits +Int32 1);

  enumRange32 0 n { i => 0 >^ symbols[i] };
  enumRange32 0 (maxbits +Int32 1) { i => 0 >^ bl_count[i] };
  enumRange32 0 n { i =>
    x = lengths[i] |> cast_i64_to_i32;
    (bl_count[x] +Int32 1) >^ bl_count[x];
  };

  /* 2) Find the numerical value of the smallest code for each code length. */
  0 >^ bl_count[0];
  foldRange 1 (maxbits +Int32 1) 0 { code => bits =>
    ncode = (code +Int32 bl_count[bits -Int32 1]) `bitshl-Int32` 1;
    ncode >^ next_code[bits];
    ncode
  };

  /* 3) Assign numerical values to all codes, using consecutive values for all
  codes of the same length with the base values determined at step 2. */
  enumRange32 0 n { i =>
    len = lengths[i] |> cast_i64_to_i32;
    if len !=Int32 0 then
      (next_code[len] |> zext_i32_to_i64 )>^ symbols[i];
      (next_code[len] +Int32 1) >^ next_code[len];
    end
  }
};

addDynamicTree = { ll_lengths => d_lengths
                => outp : ResizableArrayBuilder => bp =>
  let (besti, bestsize) = foldRange 0 8 (0, 0) { i => bests =>
    let (best, bestsize) = bests;

    size = encodeTree ll_lengths d_lengths
                      (i `bitand-Int32` 1)
                      (i `bitand-Int32` 2)
                      (i `bitand-Int32` 4)
                      bp None;

    if either (bestsize ==Int32 0) (size <SInt32 bestsize)
      then (i, size)
      else bests
    end
  };

  encodeTree ll_lengths d_lengths
             (besti `bitand-Int32` 1)
             (besti `bitand-Int32` 2)
             (besti `bitand-Int32` 4)
             bp (Some outp)
};

addLZ77Block = { final => blocktype =>
                 litlens : Array Int64 => dists : Array Int64 =>
                 lstart => lend => outp => bp =>
  ll_lengths = allocDArray 288;
  ll_symbols = allocDArray 288;
  d_lengths = allocDArray 32;
  d_symbols = allocDArray 32;

  addBit outp final bp;
  addBit outp (isFixed blocktype) bp;
  addBit outp (isDynamic blocktype) bp;

  if isFixed blocktype
    then
      getFixedTree ll_lengths d_lengths; ()
    else
      getDynamicLengths litlens dists lstart lend ll_lengths d_lengths;
      addDynamicTree ll_lengths d_lengths outp bp; ()
  end;

  zopfliLengthsToSymbols ll_lengths 288 15 ll_symbols;
  zopfliLengthsToSymbols  d_lengths  32 15  d_symbols;

  detect_block_size = rabSize outp |> zext_Word_to_i64;

  addLZ77Data outp bp litlens dists lstart lend
              ll_symbols ll_lengths d_symbols d_lengths;

  addHuffmanBits outp (ll_symbols[256] |> trunc_i64_to_i32)
                      (ll_lengths[256] |> trunc_i64_to_i32) bp;

  uncompressedSize = foldRange lstart lend 0 { i => sz =>
    sz +Int64 (if dists[i] ==Int64 0 then 1 else litlens[i] end)
  };

  compressed_size = (rabSize outp |> zext_Word_to_i64) -Int64 detect_block_size;
  compressed_size;
};


/*
Encodes the Huffman tree and returns how many bits its encoding takes. If out
is a null pointer, only returns the size and runs faster.
*/
// deflate.c:104
encodeTree :: { Array Int64 => Array Int64 =>
                Int32 => Int32 => Int32 =>
                Ref Word => Maybe ResizableArrayBuilder =>
                                    Int32 };
encodeTree = { ll_lengths => d_lengths =>
               use_16_i => use_17_i => use_18_i =>
               bp => mb_outp =>

  clcounts  = allocDArray:[Int64] 19; // size_t
  clcl      = allocDArray:[Int64] 19; // unsigned  /* Code length code lengths. */
  clsymbols = allocDArray:[Int64] 19; // unsigned

  /* The order in which code length code lengths are encoded as per deflate. */
  order = prim mach-array-literal :[Int32]
               16  17  18  0  8  7  9  6  10  5  11  4  12  3  13  2  14  1  15;

  not_size_only = isSome mb_outp;

  rle_mb = case mb_outp        // (rle, rle_bits)
             of $Some _ -> Some (newResizableArrayBuilder ! , newResizableArrayBuilder !)
             of $None   -> None
           end;

  use16 = use_16_i !=Int32 0;
  use17 = use_17_i !=Int32 0;
  use18 = use_18_i !=Int32 0;

  enumRange32 0 19 { i => 0 >^ clcounts[i] };

  //unsigned hlit = 29;  /* 286 - 257 */
  //unsigned hdist = 29;  /* 32 - 1, but gzip does not like hdist > 29.*/

  /* Trim zeros. */
  hlit = findLastSatisfyingFromToOrZero  29 1 { i => ll_lengths[256 +Int32 i] !=Int64 0 };
  hdist = findLastSatisfyingFromToOrZero 29 1 { i => d_lengths[i] !=Int64 0 };

  hlit2 =  hlit +Int32 257;
  hdist2 = hlit +Int32 1  ;

  /* Total amount of literal, length, distance codes. */
  /* Runlength encoded version of lengths of litlen and dist trees. */
  lld_total = hlit2 +Int32 hdist2;

  enumRange32 0 lld_total { i0 =>
    /* This is an encoding of a huffman tree, so now the length is a symbol */
    //unsigned char symbol = i < hlit2 ? ll_lengths[i] : d_lengths[i - hlit2];
    symbol = if i0 <SInt32 hlit2
               then ll_lengths[i0]
               else d_lengths[i0 -Int32 hlit2]
             end;

    count = prim ref 1;

    if either use16
             ((symbol ==Int64 0) `both` (either use17 use18)) then
      REC go = { j =>
        targetsym = if j <SInt32 hlit2
                      then ll_lengths[j]
                      else d_lengths[j]
                    end;
        if both (j <SInt32 lld_total)
                (symbol ==Int64 targetsym)
           then (count^ +Int32 1) >^ count;
                go (j +Int32 1)
           else ()
        end
      };
      go (i0 +Int32 1)
    end;

    i = i0 +Int32 count^ -Int32 1;

    /* Repetitions of zeroes */
    if (symbol ==Int64 0) `both` (count^ >=SInt32 3) then
      if use18 then
        while { count^ >=SInt32 11 } {
          count2 = if count^ >SInt32 138 then 138 else count^ end;
          case rle_mb
            of $Some (rle, rle_bits) ->
                rabAppendWord8 rle      18;
                rabAppendWord8 rle_bits (count2 -Int32 11 |> cast_i32_to_i8);
            of $None -> ()
          end;
          (clcounts[18] +Int64 1) >^ clcounts[18];
          (count^ -Int32 count2)  >^ count;
        };
      end;

      if use17 then
        while { count^ >=SInt32 3 } {
          count2 = if count^ >SInt32 10 then 10 else count^ end;
          case rle_mb
            of $Some (rle, rle_bits) ->
                rabAppendWord8 rle      17;
                rabAppendWord8 rle_bits (count2 -Int32 3 |> cast_i32_to_i8);
            of $None -> ()
          end;
          (clcounts[17] +Int64 1) >^ clcounts[17];
          (count^ -Int32 count2)  >^ count;
        }
      end;
    end;

    symbol32 = symbol |> trunc_i64_to_i32;
    /* Repetitions of any symbol */
    if both use16 (count^ >=SInt32 4) then
      (count^ -Int32 1) >^ count;  /* Since the first one is hardcoded. */
      (clcounts[symbol32] +Int64 1) >^ clcounts[symbol32];
      case rle_mb
        of $Some (rle, rle_bits) ->
            rabAppendWord8 rle     (symbol |> cast_i64_to_i8);
            rabAppendWord8 rle_bits 0;
        of $None -> ()
      end;
      while { count^ >=SInt32 3 } {
        count2 = if count^ >SInt32 6 then 6 else count^ end;
        case rle_mb
          of $Some (rle, rle_bits) ->
              rabAppendWord8 rle      16;
              rabAppendWord8 rle_bits (count2 -Int32 3 |> cast_i32_to_i8);
          of $None -> ()
        end;
        (clcounts[16] +Int64 1) >^ clcounts[16];
        (count^ -Int32 count2)  >^ count;
      }
    end;

    /* No or insufficient repetition */
    (clcounts[symbol32] +Int64 (count^ |> zext_i32_to_i64)) >^ clcounts[symbol32];
    enumRange32 0 count^ { i_ =>
      case rle_mb
        of $Some (rle, rle_bits) ->
            rabAppendWord8 rle      (symbol |> cast_i64_to_i8);
            rabAppendWord8 rle_bits 0;
        of $None -> ()
      end;
    };
  };

  zopfliCalculateBitLengths clcounts 7 clcl;

  if not_size_only then zopfliLengthsToSymbols clcl 19 7 clsymbols end;

  hclen = 15;
  /* Trim zeros. */
  //while (hclen > 0 && clcounts[order[hclen + 4 - 1]] == 0) hclen--;
  hclen = findLastSatisfyingFromToOrZero 15 1
                  { i => clcounts[order[i +Int32 3]] !=Int64 0 };

  case mb_outp
    of $Some outp ->
        addBits outp hlit  5 bp;
        addBits outp hdist 5 bp;
        addBits outp hclen 4 bp;

        enumRange32 0 (hclen +Int32 4) { i : Int32 =>
          v = clcl[order[i]];
          addBits outp (v |> trunc_i64_to_i32) 3 bp;
        };

        case rle_mb
           of $Some (rle, rle_bits) ->
                rle_size = rabSize rle |> trunc_Word_to_i32;
                enumRange32 0 rle_size { i =>
                  rlei = rabReadWord8 rle      (zext_i32_to_Word i) |> zext_i8_to_i32;
                  rleb = rabReadWord8 rle_bits (zext_i32_to_Word i) |> zext_i8_to_i32;

                  addHuffmanBits outp (clsymbols[rlei] |> trunc_i64_to_i32)
                                      (clcl[rlei]      |> trunc_i64_to_i32) bp;
                  /* Extra bits. */
                  if rlei ==Int32 16 then addBits outp rleb 2 bp end;
                  if rlei ==Int32 17 then addBits outp rleb 3 bp end;
                  if rlei ==Int32 18 then addBits outp rleb 7 bp end;
                };
           of $None          -> ()
        end
    of $None -> ()
  end;

  // Return result size:
  14 // hlit, hdist, hclen bits
      +Int32 (hclen +Int32 4) *Int32 3 // clcl bits
      +Int32 (clcounts[16] |> trunc_i64_to_i32) *Int32 2
      +Int32 (clcounts[17] |> trunc_i64_to_i32) *Int32 3
      +Int32 (clcounts[18] |> trunc_i64_to_i32) *Int32 7
      +Int32 (foldRange 0 19 0 { i => acc => acc +Int32 cast_i64_to_i32 (clcl[i] *Int64 clcounts[i]) });
};


calculateTreeSize = { ll_lengths : Array Int64 => d_lengths =>
  foldRange 0 8 0 { i => res =>
    size = encodeTree ll_lengths d_lengths
                      (i `bitand-Int32` 1)
                      (i `bitand-Int32` 2)
                      (i `bitand-Int32` 4)
                      (prim ref 0) None |> zext_i32_to_i64;
    if either (res ==Int64 0) (size <SInt64 res)
      then size
      else res
    end
  };
};

/// {{{ Util functions
// Input must be between 0 and 258, inclusive.
// returned value is in range [257-285]
zopfliGetLengthSymbol :: { Int64 => Int32 };
zopfliGetLengthSymbol = { x64 =>
  x = x64 |> trunc_i64_to_i32;
  table = prim mach-array-literal
    0 0 0 257 258 259 260 261 262 263 264
    265 265 266 266 267 267 268 268
    269 269 269 269 270 270 270 270
    271 271 271 271 272 272 272 272
    273 273 273 273 273 273 273 273
    274 274 274 274 274 274 274 274
    275 275 275 275 275 275 275 275
    276 276 276 276 276 276 276 276
    277 277 277 277 277 277 277 277
    277 277 277 277 277 277 277 277
    278 278 278 278 278 278 278 278
    278 278 278 278 278 278 278 278
    279 279 279 279 279 279 279 279
    279 279 279 279 279 279 279 279
    280 280 280 280 280 280 280 280
    280 280 280 280 280 280 280 280
    281 281 281 281 281 281 281 281
    281 281 281 281 281 281 281 281
    281 281 281 281 281 281 281 281
    281 281 281 281 281 281 281 281
    282 282 282 282 282 282 282 282
    282 282 282 282 282 282 282 282
    282 282 282 282 282 282 282 282
    282 282 282 282 282 282 282 282
    283 283 283 283 283 283 283 283
    283 283 283 283 283 283 283 283
    283 283 283 283 283 283 283 283
    283 283 283 283 283 283 283 283
    284 284 284 284 284 284 284 284
    284 284 284 284 284 284 284 284
    284 284 284 284 284 284 284 284
    284 284 284 284 284 284 284 285
  ;

  table[x]
};

zopfliGetLengthExtraBits :: { Int64 => Int32 };
zopfliGetLengthExtraBits = { x =>
  table = prim mach-array-literal
    0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1
    2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
    4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
    4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
    4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
    5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 0
  ;

  table[x |> trunc_i64_to_i32]
};

zopfliGetLengthExtraBitsValue :: { Int64 => Int32 };
zopfliGetLengthExtraBitsValue = { x =>
  table = prim mach-array-literal
    0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 2 3 0
    1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 4 5 6 7 0 1 2 3 4 5
    6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6
    7 8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7 8 9 10 11 12
    13 14 15 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 1 2
    3 4 5 6 7 8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7 8 9
    10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
    29 30 31 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
    18 19 20 21 22 23 24 25 26 27 28 29 30 31 0 1 2 3 4 5 6
    7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
    27 28 29 30 31 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
    16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 0
  ;

  table[x |> trunc_i64_to_i32]
};

zopfliGetDistExtraBits :: { Int64 => Int32 };
zopfliGetDistExtraBits = { dist64 =>
  dist = dist64 |> trunc_i64_to_i32;
  if dist <SInt32 5
    then 0
    else (31 `bitxor-Int32` (ctlz-Int32 (dist -Int32 1))) -Int32 1
  end
};

zopfliGetDistExtraBitsValue :: { Int64 => Int32 };
zopfliGetDistExtraBitsValue = { dist64 =>
  dist = dist64 |> trunc_i64_to_i32;
  if dist <SInt32 5
    then 0
    else x = zopfliGetDistExtraBits dist64;
         (dist -Int32 (1 +Int32 (1 `bitshl-Int32` x))) `bitand-Int32`
             ((1 `bitshl-Int32` (x -Int32 1)) -Int32 1)
  end
};

zopfliGetDistSymbol :: { Int64 => Int32 };
zopfliGetDistSymbol = { dist64 =>
  dist = dist64 |> cast_i64_to_i32;
  if dist <SInt32 5
    then dist -Int32 1
    else x = zopfliGetDistExtraBits dist64;
         r = ((dist -Int32 1) `bitlshr-Int32` (x -Int32 1)) `bitand-Int32` 1;
         x +Int32 x +Int32 r;
  end
};
// }}}

calculateBlockSymbolSize = { ll_lengths : Array Int64 => d_lengths =>
                             litlens : Array Int64 => dists : Array Int64 =>
                             lstart => lend =>
  res0 = foldRange lstart lend 0 { i => res =>
            if dists[i] ==Int64 0
              then
                res +Int64 ll_lengths[ litlens[i] |> trunc_i64_to_i32 ]
              else
                res +Int64 ll_lengths[ zopfliGetLengthSymbol litlens[i] ]
                    +Int64  d_lengths[ zopfliGetDistSymbol   dists[i]   ]
                    +Int64 (zopfliGetLengthExtraBits litlens[i] |> zext_i32_to_i64)
                    +Int64 (zopfliGetDistExtraBits dists[i]     |> zext_i32_to_i64)
            end
         };
  res0 +Int64 ll_lengths[256];
};

getFixedTree = { ll_lengths : Array Int64 => d_lengths =>
  enumRange32   0 144 { i => 8 >^ ll_lengths[i] };
  enumRange32 144 256 { i => 9 >^ ll_lengths[i] };
  enumRange32 256 280 { i => 7 >^ ll_lengths[i] };
  enumRange32 280 288 { i => 8 >^ ll_lengths[i] };
  enumRange32   0  32 { i => 5 >^ d_lengths[i] };
};

zopfliCalculateBlockSize = { litlens => dists => lstart => lend => btype =>
  ll_lengths = allocDArray 288;
  d_lengths  = allocDArray 32;

  result0 = 3; // bfinal and btype repr bits
  result1 = case btype
                of $DeflateNonCompressedBlock -> prim kill-entire-process "zopfliCalculateBlockSize called on uncompressed block"
                of $DeflateFixedBlock   -> getFixedTree ll_lengths d_lengths;
                                           0
                of $DeflateDynamicBlock -> getDynamicLengths litlens dists lstart lend ll_lengths d_lengths;
                                           calculateTreeSize ll_lengths d_lengths;
              end;

  result0 +Int64 result1 +Int64 calculateBlockSymbolSize ll_lengths d_lengths litlens dists lstart lend;
};

type case ZopfliLZ77Store
      of $ZopfliStoreEmpty
      of $ZopfliStoreLiterals (Array Int64)
      of $ZopfliStoreLengths  (Array Int64) (Array Int64) // lengths, dists
      ;

getStoreLitlens = { store =>
  case store
    of $ZopfliStoreEmpty -> prim kill-entire-process "no litlens for empty store";
    of $ZopfliStoreLiterals lits -> lits
    of $ZopfliStoreLengths lens dists -> lens
  end
};

getStoreDists = { store =>
  case store
    of $ZopfliStoreEmpty -> prim kill-entire-process "no dists for empty store";
    of $ZopfliStoreLiterals lits -> prim kill-entire-process "no dists for just literals";
    of $ZopfliStoreLengths lens dists -> dists
  end
};

getStoreSize = { store => getStoreLitlens store |> arrayLength32 };


type case ZopfliBlockState
      of $ZopfliBlockState /*ZopfliOptions*/ Int64 Int64 // block start, end
      ;

type case SymbolStats
       of $SymbolStats (Array Int64)   (Array Int64) // litlens, dists
                       (Array Float64) (Array Float64) // ll_symbols, d_symbols
       ;

mkSymbolStats = {
  SymbolStats (newDArray0 288 { i => 0 })
              (newDArray0  32 { i => 0 })
              (newDArray0 288 { i => 0.0 })
              (newDArray0  32 { i => 0.0 })
};

getLitLens = { stats =>
  case stats of $SymbolStats litlens dists llsyms dsyms -> litlens end
};

getDists = { stats =>
  case stats of $SymbolStats litlens dists llsyms dsyms -> dists end
};

getLLSymbols = { stats =>
  case stats of $SymbolStats litlens dists llsyms dsyms -> llsyms end
};

getDSymbols = { stats =>
  case stats of $SymbolStats litlens dists llsyms dsyms -> dsyms end
};

type case RanState
      of $RanState (Ref Int32) (Ref Int32)
      ;

mkRanState = {
  RanState (prim ref 1) (prim ref 2)
};


zopfliCalculateEntropy = { count : Array Int64 => bitlengths : Array Float64 =>
  kInvLog2 = 1.4426950408889;  /* 1.0 / log(2.0) */
  n = arrayLength32 count;
  sum = foldRange 0 n 0 { i => sum => sum +Int64 count[i] };
  log2sum = if sum ==Int64 0 then log-s32 n else log-s64! sum end *f64 kInvLog2;
  enumRange32 0 n { i =>
    /* When the count of the symbol is 0, but its cost is requested anyway, it
    means the symbol will appear at least once anyway, so give it the cost as if
    its count is 1.*/
    if count[i] ==Int64 0
      then  log2sum                                       >^ bitlengths[i];
      else (log2sum -f64 log-s64! count[i] *f64 kInvLog2) >^ bitlengths[i];
    end;
    /* Depending on compiler and architecture, the above subtraction of two
    floating point numbers may give a negative result very close to zero
    instead of zero (e.g. -5.973954e-17 with gcc 4.1.2 on Ubuntu 11.4). Clamp
    it to zero. These floating point imprecisions do not affect the cost model
    significantly so this is ok. */
    if both (bitlengths[i] <f64 0.0)
            (bitlengths[i] >f64 -0.00001) then
      0.0 >^ bitlengths[i];
    end;
    //assert(bitlengths[i] >= 0);
  };
};

/* Calculates the entropy of the statistics */
calculateStatistics = { stats =>
  case stats
    of $SymbolStats litlens dists ll_symbols d_symbols ->
      zopfliCalculateEntropy litlens ll_symbols;
      zopfliCalculateEntropy dists   d_symbols;
  end;
};

/* Appends the symbol statistics from the store. */
getStatistics = { store => stats =>
  enumRange32 0 (getStoreSize store) { i =>
    if (getStoreDists store)[i] ==Int64 0
      then x = (getStoreLitlens store)[i];
           a = getLitLens stats;
           (a[x] +Int64 1) >^ a[x];
      else
           xl = zopfliGetLengthSymbol (getStoreLitlens store)[i];
           ((getLitLens stats)[xl] +Int64 1) >^ (getLitLens stats)[xl];

           xl = zopfliGetDistSymbol (getStoreDists store)[i];
           ((getDists stats)[xl] +Int64 1) >^ (getDists stats)[xl];
    end;
  };
  1 >^ (getLitLens stats)[256];

  calculateStatistics stats;
};

kZOPFLI_WINDOW_SIZE = { 1024 }; // TODO

type case ZopfliHash
      of $ZopfliHash (Array Int64) (Array Int32) (Array Int64) (Ref Int64)
     end;


zopfliInitHash = { windowsize : Int32 =>
  head    = newDArray0 65536 { i => 0 -Int64 1 };
  prev    = newDArray0 windowsize { i => i };
  hashval = newDArray0 windowsize { i => 0 -Int64 1 };

  ZopfliHash head prev hashval (prim ref 0);
};

kHASH_SHIFT = { 5 };
kHASH_MASK  = { 32767 };

zopfliUpdateHashValue = { h : ZopfliHash => byt : Int8 =>
  case h of $ZopfliHash head prev hashval valref ->
    newval = ((valref^ `bitshl-Int64` (kHASH_SHIFT !))
              `bitxor-Int64` (zext_i8_to_i64 byt))
              `bitand-Int64` (kHASH_MASK !);
    newval >^ valref;
  end
};

zopfliWarmupHash = { inp : Bytes => windowstart : Int64 => inend : Int64 => h : ZopfliHash=>
  zopfliUpdateHashValue h (bytesGet! inp windowstart);
  if (windowstart +Int64 1) <SInt64 inend then
    zopfliUpdateHashValue h (bytesGet! inp (windowstart +Int64 1))
  end
};

zopfliUpdateHash = { inp : Bytes => pos : Int64 => inend : Int64 => h : ZopfliHash =>
  // hash.c:91

  hpos = pos `bitand-Int64` (kZOPFLI_WINDOW_MASK !);

  baz = if (pos +Int64 (kZOPFLI_MIN_MATCH !)) <=SInt64 inend then
      bytesGet! inp (pos +Int64 (kZOPFLI_MIN_MATCH !) -Int64 1) else 0 end;
  zopfliUpdateHashValue h baz;
  case h of $ZopfliHash head prev hashval valref ->
      valref^ >^ hashval[hpos];
      case (head[valref^] !=Int64 -1, hashval[head[valref^]] == valref^)
        of (True, True) -> head[valref^] >^ prev[hpos];
        of _ ->                     hpos >^ prev[hpos];
      end;
      hpos >^ head[valref^];
  end;
};

/*
Appends the length and distance to the LZ77 arrays of the ZopfliLZ77Store.
context must be a ZopfliLZ77Store*.
*/
// lz77.c:97
zopfliStoreLitLenDist = { leng : Int32 => dist : Int32 => i : Int64 => storeref =>
  size_t i;
  /* Needed for using ZOPFLI_APPEND_DATA multiple times. */
  size_t origsize = store->size;
  size_t llstart = ZOPFLI_NUM_LL * (origsize / ZOPFLI_NUM_LL);
  size_t dstart = ZOPFLI_NUM_D * (origsize / ZOPFLI_NUM_D);

  /* Everytime the index wraps around, a new cumulative histogram is made: we're
  keeping one histogram value per LZ77 symbol rather than a full histogram for
  each to save memory. */
  if (origsize % ZOPFLI_NUM_LL == 0) {
    size_t llsize = origsize;
    for (i = 0; i < ZOPFLI_NUM_LL; i++) {
      ZOPFLI_APPEND_DATA(
          origsize == 0 ? 0 : store->ll_counts[origsize - ZOPFLI_NUM_LL + i],
          &store->ll_counts, &llsize);
    }
  }
  if (origsize % ZOPFLI_NUM_D == 0) {
    size_t dsize = origsize;
    for (i = 0; i < ZOPFLI_NUM_D; i++) {
      ZOPFLI_APPEND_DATA(
          origsize == 0 ? 0 : store->d_counts[origsize - ZOPFLI_NUM_D + i],
          &store->d_counts, &dsize);
    }
  }

  ZOPFLI_APPEND_DATA(length, &store->litlens, &store->size);
  store->size = origsize;
  ZOPFLI_APPEND_DATA(dist, &store->dists, &store->size);
  store->size = origsize;
  ZOPFLI_APPEND_DATA(pos, &store->pos, &store->size);
  assert(length < 259);

  if (dist == 0) {
    store->size = origsize;
    ZOPFLI_APPEND_DATA(length, &store->ll_symbol, &store->size);
    store->size = origsize;
    ZOPFLI_APPEND_DATA(0, &store->d_symbol, &store->size);
    store->ll_counts[llstart + length]++;
  } else {
    store->size = origsize;
    ZOPFLI_APPEND_DATA(ZopfliGetLengthSymbol(length),
                       &store->ll_symbol, &store->size);
    store->size = origsize;
    ZOPFLI_APPEND_DATA(ZopfliGetDistSymbol(dist),
                       &store->d_symbol, &store->size);
    store->ll_counts[llstart + ZopfliGetLengthSymbol(length)]++;
    store->d_counts[dstart + ZopfliGetDistSymbol(dist)]++;
  }
};

// lz77.c:543
// no lazy matching
zopfliLZ77Greedy = { state => inp : Bytes => storeref =>
  instart = 0;
  inend   = bytesLength inp;

  if instart ==Int64 inend
    then ()
    else
      leng = prim ref 0;
      dist = prim ref 0;
      dummysublen = allocDArray 259;
      windowstart = if instart >SInt64 (kZOPFLI_WINDOW_SIZE !)
                      then instart -Int64 (kZOPFLI_WINDOW_SIZE !) else 0 end;

      h = zopfliInitHash (kZOPFLI_WINDOW_SIZE !);
      zopfliWarmupHash inp windowstart inend h;
      enumRange windowstart instart { i =>
        zopfliUpdateHash inp i inend h;
      };

      enumRange instart inend { i =>
        zopfliUpdateHash inp i inend h;

        zopfliFindLongestMatch s h inp i inend (kZOPFLI_MAX_MATCH !) dummysublen
                               distref lengref;
        lengthscore = getLengthScore lengref^ distref^;

        /* Add to output. */
        if lengthscore >= (kZOPFLI_MIN_MATCH !) then
          zopfliVerifyLenDist inp inend i distref^ lengref^;
          zopfliStoreLitLenDist lengref^ distref^ i storeref;
        else
          1 >^ lengref;
          zopfliStoreLitLenDist (bytesGet! inp i) 0 i storeref;
        end;

        enumRange 1 leng { j =>
          //assert(i < inend); i++;
          i_curr = i +Int64 j;
          zopfliUpdateHash inp i_curr inend h;
        };
      };
  end
};

zopfliLZ77Optimal = { state => inp => store =>
  /* Dist to get to here with smallest cost. */
  blocksize = bytesLength inp;
  blocksize32 = cast_i64_to_i32 blocksize;
  length_array = allocDArray (blocksize32 +Int32 1);

  path = prim ref (prim mach-array-literal);

  currentstore = prim ref ZopfliStoreEmpty;
  stats = mkSymbolStats !;

  one_e_15 = 1`000`000`000`000`000.0;
  zop_lg_flt = one_e_15 *f64 one_e_15;
  bestcost = prim ref zop_lg_flt; // ZOPFLI_LARGE_FLOAT;
  lastcost = prim ref 0.0;
  /* Try randomizing the costs a bit once the size stabilizes. */
  ran_state = mkRanState !;
  lastrandomstep = prim ref (0 -Int32 1);

  /* Do regular deflate, then loop multiple shortest path runs, each time using
  the statistics of the previous run. */

  /* Initial run. */
  zopfliLZ77Greedy state inp currentstore;
  getStatistics currentstore stats;

  /* Repeat statistics with each time the cost model from the previous stat
  run. */
  // s = state
  enumRange32 0 (getNumIterations (getOptions state)) { i =>
    zopfliCleanLZ77Store currentstore;
    zopfliInitLZ77Store  currentstore;
    lz77OptimalRun state inp path
                   length_array
                   { litlen => dist =>
                     if dist ==Int32 0
                       then (getLLSymbols stats)[litlen]
                       else lsym = zopfliGetLengthSymbol litlen;
                            lbits = zopfliGetLengthExtraBits litlen;
                            dsym  = zopfliGetDistSymbol dist;
                            dbits = zopfliGetDistExtraBits dist;
                            (  getLLSymbols stats)[lsym] +f64
                              (getDSymbols  stats)[dsym] +f64
                              lbits +f64 dbits
                     end
                   }
                   currentstore;
    cost = zopfliCalculateBlockSize (getStoreLitlens currentstore) (getStoreDists currentstore)
                                    0 (getStoreSize currentstore) 2;
    if cost <f64 bestcost^ then
      /* Copy to the output store. */
      zopfliCopyLZ77Store currentstore store;
      copyStats stats beststats;
      cost >^ bestcost;
    end;

    copyStats stats laststats;
    clearStatFreqs stats;
    getStatistics currentstore stats;
    if lastrandomstep^ !=Int32 -1 then
      /* This makes it converge slower but better. Do it only once the
      randomness kicks in so that if the user does few iterations, it gives a
      better result sooner. */
      addWeighedStatFreqs stats  1.0 laststats 0.5 stats;
      calculateStatistics stats;
    end;

    if both (i >SInt32 5) (cost ==f64 lastcost^) then
      copyStats beststats stats;
      randomizeStatFreqs ran_state stats;
      calculateStatistics stats;
      i >^ lastrandomstep;
    end;

    cost >^ lastcost;
  };

  //free(length_array);
  //free(path);
  //ZopfliCleanLZ77Store(&currentstore);
};

zopfliDeflateDynamicBlock = { outp => inp => final =>
  //// btype = 2, instart = 0

  blocksize = bytesLength inp; // not used since we didn't port the assertion it flows to.
  store = prim ref ZopfliStoreEmpty;
  state = ZopfliBlockState 0 blocksize;

  zopfliLZ77Optimal state inp store;

  // TODO encoding with fixed tree

  bp = prim ref 0;
  case store^
    of $ZopfliStoreLengths lits dists ->
      addLZ77Block final DeflateDynamicBlock
                   lits dists
                   0 (arrayLength32 lits)
                   outp bp;
    of _ ->
      prim kill-entire-process "zopfliDeflateDynamicBlock expected store to have lengths not literals";
  end;

  //ZopfliCleanLZ77Store(&store);
  ()
};

gzipCompress = { inp : Bytes =>
  outp = newResizableArrayBuilder !;

  // ID1, ID2, CM, FLG
  rabAppendWord8 outp 31;
  rabAppendWord8 outp 139;
  rabAppendWord8 outp 8;
  rabAppendWord8 outp 0;

  rabAppendWord32 outp 0; // MTIME

  rabAppendWord8 outp 2; // XFL, OS
  rabAppendWord8 outp 3;

  final = True;
  zopfliDeflateDynamicBlock outp inp final;

  rabAppendWord32 outp (crcBytes inp);
  rabAppendWord32 outp (bytesLength32 inp);

  rabToBytes outp
};

main = {
  print_i32x (crcBytes (bytesOfRawArray b"1234"));
  expect_i32x 0x9be3e0a3;

  expect_i32 0;
  print_i32 (findLastSatisfyingFromToOrZero 3 1
                   { i => (prim mach-array-literal 1 2 3 4)[i] ==Int32 0 });

  expect_i32 3;
  print_i32 (findLastSatisfyingFromToOrZero 3 1
                   { i => (prim mach-array-literal 1 2 3 0)[i] ==Int32 0 });

  expect_i32 3;
  print_i32 (findLastSatisfyingFromToOrZero 3 1
                   { i => (prim mach-array-literal 1 0 3 0)[i] ==Int32 0 });

  expect_i32 1;
  print_i32 (findLastSatisfyingFromToOrZero 3 1
                   { i => (prim mach-array-literal 1 0 3 1)[i] ==Int32 0 });

  expect_i32 0;
  print_i32 (findLastSatisfyingFromToOrZero 3 1
                   { i => (prim mach-array-literal 0 1 3 1)[i] ==Int32 0 });

  expect_i32 0;
  print_i32 (findLastSatisfyingFromToOrZero 3 0
                   { i => (prim mach-array-literal 0 1 3 1)[i] ==Int32 0 });
};