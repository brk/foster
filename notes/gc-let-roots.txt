With code like

        let a = new f(...) in
        let b = new g(a) in
        let c = new h(b) in
                ... body ...

the semantics of let and gcroot require that all of a, b, and c be visible in
body, with different values, even if they are not used. This in turn implies
that there must be stack space allocated for the roots, and without further
optimizations, a GC occurring in body will perform some amount of needless
work in tracing a, b, and c.

One optimization is to do live variable analysis and null out pointers after
they become dead. This should be done only if a GC may occur before the pointer
goes out of scope; otherwise, the null stores themselves are unnecessary work.
Note that this requires may-allocate information.

Another option is to simply provide first class assignment.

The extra functions and function calls created for the purely-functional style
can often be eliminated by LLVM's optimization passes, but it's probably better
not to rely on that for "guarantees" of performance. Better to find ways to
ensure that there won't be an abstraction penalty.
